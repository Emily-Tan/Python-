
<<python 语言开发基础>>

python 的简介:
  创始人: Guido van Rossum(荷兰人)
  时间: 1989 圣诞节期间
  Python的命名: 源于一个喜剧团 Monty Python

python 的应用领域
  系统运维
  网络编程
  科学计算
  人工智能，机器人
  web 开发
  大数据及数据库编程
  云计算
  教育
  游戏，图像
  其它

python 的优缺点
  优点：
  　面向对象(Java, C++, Python)
    免费
    可移植
    可混合编程(C/C++/Java/.net)
    简单易学易用
    应用领域广泛
    开发效率高
    开源
  缺点:
    与C/C++相比执行速度不够快
    不能封闭源代码

python 的官网:
  www.python.org

python 的版本
  python v2.7(2020年结束维护)
  python v3.5 (当前教学版本)
  python v3.8 (最新版本)

python 的安装:
  windows / Mac OS X / Unix ...

python 的运行
  python 的解释执行器　
  　CPython (python3)
    Jython
    IronPython
    PyPy

python的运行:
　 # 方法1
   $ python3 hello.py
   # 方法　２
   # 在hellp.py 的第一行写入:
       #! /usr/bin/python3
   $ chmod u+x hello.py
   $ ./hello.pyh

python 的交互提示模式
　　$ python3
  >>>   # <-- 可以在>>>提示符下输入语句

  退出:
    ctrl + d
    >>> quit()
    >>> exit()

python 的注释:
  # 井号开头，直到行尾
  作用:让注释内容不参加解释执行

python 的核心数据类型:
  数字(整数, 浮点数，复数，布尔型)
  字符串
  列表等

python程序的组成:
程序由模块组成
模块由语句，函数，类，数据等组成
语句包含表达式
表达式建立并处理数据对象

python 注释
以 # 号开头，至直行尾

python 核心数据类型：
数字(整型int，浮点型float，复数complex, 布尔型bool)
字符串
列表等

整型数int
整型数是不带小数部分的数字。包括自然数，0,及负数
如 : -5, 10000, 0等

整型数的字面值表示方式:
十进制表示:
    10
    200
    99999999
    9999999999999999999999999999999999
二进制表示(0b开头,后跟0~1):
    0b111
    0b101
    0b11111111
八进制方式表示(0o开头，后跟0~7)
0o177  # 127
0o11   # 9
十六进制表示(0x开头,后跟0~9, A~F,a-f)
0x11  # 17
0xFF  # 255

进制转换:
十进制(逢十进一)
二进制(逢二进一)
八进制(逢八进一)
十六进制(逢十六进一)

练习:
计算 0xFFFF 表示多少 65535
计算 0b1001 表示多少 9
计算 0o71   表示多少  57
试把 13   转为二进制表示  0b1101
把 18   转为十六进制表示 0x12

浮点型数 float 
浮点型数是带有小数部分的数字
表示方式:
小数形式:
3.14  3.1  3.   0.14  .14
科学计数法:
格式:
小数 e/E(正负号) 指数
如:
   6.18E-1
   2.9979e8

复数 complex
分为两部分:
实部(real)
虚部(image)
虚部以j或J结尾
字面值
    1j, (2j), 1+1J, 3-4J, (-100+100J)

布尔类型数bool
用来表示真和假两个状态的类型
    True 表示真(条件满足或成立)
Flase表示假(条件不满足或不成立)
说明:
    True 的值为1
    False 的值为0
空值 None 对象
  None 是一个表示不存在的特殊对象
作用:
用来占位
用来变量解除绑定

表达式和运算符(也叫操作符)
表达式 expression
由一个数字或数字和运算符组成
作用:
通常让计算机做一些事情并返回结果
例:
    1 + 2

运算符:
算术运算符:
    +  加法
    -  减法
    *  乘法
    /  除法
    // 地板除
    % 求余
    ** 幂运算
除法:
除法得到的数是浮点数，不会丢弃小数部分
  1/3 = 0.3333333333333333
  4/2 = 2.0

// 地板除
除的结果去掉小数部分向下取整
  7 / 3   # 得2.333333333333
  7 // 3  # 得2
  8 // 3  # 得2
  3.25 // 1.5 # 得 2.0

% 求余(也叫取模)
  10 % 3      # 得 1
  3.25 % 1.5  # 得 0.25

** 幂运算
格式:
x ** y
意为 x 的 y次方
  4 ** 2        # 得 16
  3.0 ** 4.0    # 得 27

运算符的优先级
  **
  *  /  //  %
  +  - 
示例:
  1 + 3 * 3 ** 2 + 4 // 2
  1 + 3 * 9 + 4 // 2
  1 + 27 + 4 // 2
  1 + 27 + 2
  28 + 2
  30

括号分组子表达式
用()可以将表达式分组，()内的表达式先进行计算

混合类型自动升级
  1 + 2.14 返回浮点数 3.14

基本输出函数：print
格式：print（要打印的数据），各个数据可以用逗号“，”隔开
示例：print('hello')
print(1+2+3)

变量 variable
什么是变量：
用来绑定数据对象的标识符
变量的命名规则：
    1. 变量名必须为字母或下划线开头，后跟字母或下划线或数字
    2. 不能使用python的关键字命名

合法的变量名示例：
a a1 b bbb   _aaa_   _Abcdvara1b2c2
不合法的变量名示例：
    1a   123   $ABC  +a  -b   #ab   @ab

    python 的关键字：
        True ，False,   None is  del  if  elif等

赋值语句 statement
语法：
变量名 = 表达式
或
变量名1 = 变量名2 = 表达式
或
变量名1 ，变量名2，... = 序列

作用：用于创建变量并将变量绑定（或关联）在一个对象上
说明：
     1.当变量不存在时，创建该变量同时绑定在这个对象上
     2.当变量存在时，改变此变量的绑定的对象
     3.一个变量只能绑定一个对象
     4.两个变量可以同时绑定同一个对象
示例:
     a = 10  # 创建a变量，和10绑定在一起
     b = 20
     c = a + b  #创建变量c,和10 + 20 的结果绑定在一起

python 中的名词：关联/绑定/引用的含义
    python中，变量没有类型
关联/绑定/引用都是指变量和一个对象的关联关系

在交互模式下查看变量的绑定关系：help('__main__')

python 中的自动化内存管理：
    a = 10000
    b = 20000
    a = a + b  #过程怎么进行的

序列赋值的语法：
变量名1，变量名2，... = 对象1，对象2...
变量名1，变量名2，... = [对象1，对象2...]
变量名1，变量名2，... = (对象1，对象2...)

思考：变量的交换绑定
练习：已知有两个变量：a 绑定 10000  b 绑定 20000
问：在不创建任何新的对象的情况下，如何让a和b 交换绑定的对象？
方法1：
    a = 10000
    b = 20000
    temp = a    #借助第三个变量，经典交换算法
    a = b
    b = temp

方法2：序列赋值    a, b = b , a

is / is not运算符
作用：判断两个对象是否绑定同一个对象，如果是同一个对象返回Ture,否则返回 False
    is not 与 is 相反
语法：x is y 
      x is not y
a = 10000
b = 10000
a is b    # False

小整数对象池：
CPython中整数 -5 至 256 永远保存在小整数池中，不会释放并可以重复使用
示例：
    a = 5 
    b = 5
a is b   # True

id 函数：
格式：id(对象)
作用：返回一个对象在内存中的地址

del 语句（del 是 delete 的简写）
作用：用于删除变量，同时删除与对象的绑定关系。如果可能则释放对象
语法：del 变量名

python 的内存管理和引用计数
每个对象都会记录有几个变量引用自身，当引用的数量为0时，则对象被销毁，此种自动化内存管理的方式叫引用计数。

复合赋值算术运算符：
运算符说明
     y += x        等同与 y = y + x
     y -= x        等同与 y = y - x
     y *= x        等同与 y = y * x
     y /= x        等同与 y = y / x
     y %= x        等同与 y = y % x
     y //= x       等同与 y = y // x
     y **= x       等同与 y = y ** x

比较运算符:
    <     小于
    <=    小于等于
    >     大于
    >=    大于等于
    ==    等于
    !=    不等于
  语法:
    左表达式 < 右表达式

  说明:
    比较运算符返回布尔类型的值
  示例:
    10 < 20  # True
    1 + 10 > 2 + 8  # True
    10 < 20 <= 30  # True
　　
数值对象的构造(创建)函数
float(obj)  用字符串或数字转换为浮点数，如果不能出参数则返回0
int(x,base=10)　或　int(x=0)  用数字或字符串转换为整数，如果不给出参数，则返回0
complex(r=0.0, i=0.0)  用数字创建一个复数(实部为r, 虚部为i)
bool(x)  用x创建一个布尔值(True/False)

函数调用:
  函数名(传参列表)
    说明:
      函数调用是表达式，一定会返回一个对象的引用关系

bool(x) 返回假值的情况
  None 空值
  False  布尔假值
  0, 0.0, 0j
  ''   空字符串
  ()   空元组
  []   空列表
  {}   空字典
  set() 空集合
  ...

内建的数值型函数:
  abs(x)  取x的绝对值
  round(number[, ndigits]) 对数值进行四舍五入， ndigits是小数向右取整的位数,负数表示向左取整
  pow(x, y, z=None) 相当于 x ** y 或 x ** y % z

help() 函数可查看函数帮助文档
  >>> help(函数名)

语句 statement
  语句是由一些表达式等组成，通常一条语句可以独立执行来完成一部分事情并形成结果
  一条语句建议写在一行内 
  多条语句写在一行内需要用分号(;) 分开

  示例:
    print('hello')
    x = 100 + 200
    print(x)
    # 写在一起为:
    print('hello'); x = 100 + 200; print(x)

显式换行:
  折行符 \ (反斜杠)
  必须放在一行的末尾，来示意解释执行器，下一行也是本行的语句

隐式换行:
  所有括号内的空容换行称为隐式换行
   () {} []
  如:
    x = 2 * (3 + 4
    + 5)
    print(x)

基本输入输出
基本输入函数input
  作用:
    从标准输入设备上读取一个字符串
    末尾的换行符会被删除
　　格式:
  input('提示字符串')
    返回输入的字符串(仅python3)
    注: '提示字符串' 可以为空
示例见:
input.py
s = input("请输入字符串: ")


print("您刚才输入的是:", s)


s = input("请输入整数: ")

i = int(s)  # 将字符串通过int转为整数

print(i == 100)  # True/Flase

基本输出函数 print
  作用:
    将一系列的值以字符串形式输出到标准输出设备上．默认为终端
  格式:
    print(value, ..., sep=' ', end='\n')
    关键字参数:
      sep: 两个值之间的分隔符,默认为一个空格' '
      end: 输出完毕后在末尾自动追加一个字符串，默认为换行符'\n'
示例见:
print.py
# 此示例示意print函数的用法及相应的关键字参数的用法


print(1, 2, 3, 4)

print(True, None, 3.14, 1+2J, 100)


print(1, 2, 3, 4, sep=' ')

print(1, 2, 3, 4, sep='#')

print(1, 2, 3, 4, sep=' <-> ')


print(1, 2, 3, 4)

print(1, 2, 3, 4, end='\n')

print(1, 2, 3, 4, end='')

print('hello \n\n\n world')

if 语句
 　作用:
    让程序根据条件选择性的执行某条语句或某些语句
  语法:
    if 真值表达式:
        语句块1...
    elif 真值表达式2:
        语句块2...
    elif 真值表达式3:
        语句块3...
    ...
    else:
        语句块4
  说明:
    elif 子句也可有一个或多个，也可以没有
    else 子句最多只能有一个，也可以没有      
示例见:
if.py
# 让用户输入一个整数，让程序打印出用户输入的数是奇数还是偶数
num = int(input("请输一个整数: "))
if num % 2 == 0:
    print("您输入的是偶数")
else:
    print("您输入的是奇数")

if 语句的真值表达式:
  if 100:
      print("真值")
  等同于:
  if bool(100):
      print("真值")

if 语句嵌套
  if 语句可以为作语句嵌套到另一个语句的内部

示例见:
if_embed.py
# 此示例示意if语句嵌套问题：
# 输入一个学生的成绩:
# 根据等级打印出,优，良，及格，不及格
score = int(input("请输入学生成绩: "))
if 0 <= score <= 100:
    print("成绩合法")
    if score >= 90:
        print("优")
    elif score >= 80:
        print("良")
    elif score >= 60:
        print("及格")
    else:
        print("不及格")
else:
    print("您的输入有误！")

条件表达式
　　语法:
    表达式1 if 真值表达式 else 表达式2
    作用:
    根据真值表达式的取值(True/False) 来决定执行表达式1还是表达式2,并返回相应的结果
示例见:
if_express.py
# 此示例示意条件表达式的用法
# 商场促销，满100减20
money = int(input("请输入商品总额: "))
pay = money - 20 if money >= 100 else money  # 需要支付的钱
print("您需要支付:", pay, "元")

pass 语句
  作用:
    通常用来填充语法空白
  语法:
    pass
示例见:
pass.py
# 输入一个学生的成绩，如果不在0~100范围内，则提示您输入的有误
score = int(input('请输入学生成绩'))
if 0 <= score <= 100:
    pass
else:
    print("您的输入有误!")

布尔运算
  运算符(三个):
    not    and    or
布尔非操作:
  语法:
    not x
  作用:
    对 x进行布尔取非，如: bool(x) 为True,则返回False， 否则返回True

  示例:
    money = 103
    if not money >= 100:
       pay = money
    else:
       pay = money - 20
    print(pay)

布尔与操作 and
  语法:
    x and y
      注: x, y代表表达式
  作用:
    优先返回假值对象
    当x为布尔值为False时，返回x, 否则返回y

  示例:
    >>> True and True
    True
    >>> False and True
    False
    >>> True and False
    False
    >>> False and False
    False

布尔或操作 or 
  语法:
    x or y
  作用:
    优先返回真值对象
    当 x 为True时，返回x, 否则返回y
  示例:
    >>> True or True
    True
    >>> True or False
    True
    >>> False or True
    True
    >>> False or False
    False

示例见:
bool_operator.py
# 输入一个学生的成绩，如果不在0~100范围内，则提示您输入的有误
score = int(input('请输入学生成绩'))
# if score < 0:
#     print("您的输入有误!")
# elif score > 100:
#     print("您的输入有误!")

if score < 0 or score > 100:
    print("您的输入有误!")

正负号运算符
  + (正号)
  - (负号)
    一元运算符
  语法:
    + 表达式
    - 表达式
  示例:
    a = 5
    b = -a  # b = -5
    c = +a  # c = 5
    c2 = (2-3j)
    c3 = -c2  # c3 = (-2+3j)

字符串 str
  作用:
    用来记录文本信息
  表示方法:
    在非注释中，凡是用引号括起来的部分都是字符串
      '    单引号
      "    双引号
      '''  三单引号
      """  三双引号
  空字符串的表示方法:
    ''
    ""
    ''''''
    """"""
    注: 空字符串的布尔值为False
  非空字符串表示方式:
    'hello'
    "hello"
    '''hello'''
    """hello"""
  单引号和双引号的区别:
    单引号内可以包含双引号
    双引号内可以包含单引号

  三引号字符串的作用:
    三引号字符串中的换行会自动转换为换行符 '\n'
    三引号内可以包含单引号和双引号
  示例:
    print('welcome to beijing.\nI like python!\nI am Studing!')

隐式字符串字面值拼接
  s = "I'm "  'a programer.'  'my name is "weimingze"'
  print(s)

用转义序列代表特殊字符
  字符串字面值中用字符反斜杠 \ 后跟一些字符代表特殊的一个字符

  \'     代表一个单引号(')
  \"     代表一个双引号(")
  \\     代表一个反斜杠(\)
  \n     换行
  \r     返回光标至行首
  \f     换页
  \v     垂直制表符
  \b     倒退
  \0     空字符(字符值为零)
  \0oo   oo为两位八进制表示的字符
  \xXX   XX为两位十六进制表示的字符
  \uXXXX UNICODE16 的十六进制表示的字符
  \UXXXXXXXX UNICODE32 的十六进制表示的字符

ASCII 编码
  查看ASCII 编码表:
  # man ascii<回车>

常用的ASCII编码:
  字符　　十进制    十六进制
  '0'      48       0x30
  'A'      65       0x41
  'a'      97       0x61

raw 字符串(原始字符串)
　　格式:
    r'字符串内容'
    r"字符串内容"
    r'''字符串内容'''
    r"""字符串内容"""
  作用:
    让转义符号 \ 无效
  示例：
  　a = 'C:\newfile\test.py'
    print(a)

求字符串序列的长度的函数len(x)
  返回字符串中字符的个数

序列的概念:
  字符串是序列的一种

字符串的运算:
  + 加号用于拼接字符串
    x = "ABC" + 'DEF'
    print(x)
    y = "123"
    z = x + y
  += 复合赋值
    x += y 等同于 x = x + y

  * 运算符生成重复的字符串
    x = "ABC" * 2
    print(x)
    注: 字符串只能和整数相乘

  *= 运算符:
    x *= y 等同于 x = x * y

字符串的比较运算
  运算符:
    >  >=  <  <=  ==  !=
  示例:
    "A" == 'A'    # True
    'A' < 'B'     # True
    'ABC' > 'ABB' # True
    'ADC' < 'ABC' # False
    'AD'  > 'ABC' # True
    'AB'  > 'ABC' # False
    'ABCD' != 'DCBA'  # True

in  / not in 运算符
  作用:
    in 用于序列，字典，集合等容器类中，用于判断某个值是否存在于容器中，如果存在返回True,不存在返回False
    not in 与 in运算符返回的布尔值相反
  格式:
    对象 in 序列
  示例:
    x = 'welcome to beijing'
    'to' in x  # True
    'hello' in x # False

字符串的索引 
索引 index
    python 字符串是不可以改变的字符序列
  语法:
    字符串[整数表达式]
  说明:
    python序列都可以用索引(index)来访问序列中的对象
    python 序列正向的索引从0开始,第二个索引为1,最后一个索引为len(s)-1
    python 序列的反向索引从-1开始，-1代表最后一个，-2代表倒数第二个，以此类推,第一个是-len(s)
  示例:
    s = 'ABCDE'

切片 slice
  作用:
    从字符串序列中取出一部分相应的元素重新组成一个字符串
  语法:
    字符串[(开始索引b):(结束索引e)(:(步长s))]
    注: () 内括起的部分代表可以省略
  说明:
    1. 开始索引是切片开始切下的位置0代表第一个元素，-1代表最后一个元素
    2. 结束索引是切片的终止索引(但不包含终止索引)
    3. 步长是切片每次获取完当前索引后移动的方向和偏移量
      1) 没有步长，相当于取值完成后向后移动一个索引的位置（默认为1)
      2) 当步长为正整数时，取正向切片:
         步长默认值为1, 开始索引默认值为0, 结束索引的默认值为len(s)
      3) 当步长为负整数时，取反向切片:
         反向切片时，默认的起始位置为最后一个元素，默认终止位置为第一个元素的前一个位置

  示例:
    s = 'ABCDE'
    a = s[1:4]  # a -> 'BCD'
    a = s[1:]   # a -> 'BCDE'
    a = s[:2]   # a -> 'AB'
    a = s[:]    # a -> 'ABCDE'
    a = s[4:2]  # a -> ''
    a = s[2:10000]  # a -> 'CDE' 开始索引/结束索引可以越界
    a = s[::2]  # a -> 'ACE'
    a = s[1::2] # a -> 'BD'
    a = s[::-1] # a -> 'EDCBA'
    a = s[::-2] # a -> 'ECA'
    a = s[4:0:-2]  # a -> 'EC'
  
python3中常用的序列函数
  len(x)  返回序列的长度
  max(x)  返回序列的最大值元素
  min(x)  返回序列的最小值元素

  示例:
    s = "hello"
    print(len(s))  # 5
    print(max(s))  # o
    print(min(s))  # e
  
字符串编码(encode)的转换函数
    ord(c)  返回一个字符的Unicode 值
    chr(i)  返回i这个值所对应的字符

整数转换为字符串的函数:
  hex(i)  将整数转换为十六进制的字符串
  oct(i)  将整数转换为八进制的字符串
  bin(i)  将整数转换为二进制的字符串

字符串的构造函数 str
  str(obj='')  对象转字换为字符

  str(3.14)  # '3.14'
  str(None)  # 'None'
  str(1+2j)  # '(1+2j)'

python3中常用的字符串方法(method):
  方法的调用语法:
     对象.方法名(方法传参)
  示例:
    'abc'.isalpha()  # 是正确的语法
    123.isalpha()    # 是错的

常用的字符串方法：
字符串中反斜杠字符表
转义格式    意义
\'    单引号(')
\"    双引号(")
\\    反斜杠(\ )
\n    换行
\r    返回光标至行首
\f    换页
\t    水平制表符
\v    重直制表符
\b    倒退
\0    空字符，字符值为零
\0oo    oo为两位八进制表示的字符
\xXX    XX为两位十六进制表示的字符
\uXXXX    Unicode 16的十六进制表示的字符
\UXXXXXXXX    Unicode 32的十六进制表示的字符
常用字符串方法
方法            说明
S.isdigit()    判断字符串中的字符是否全为数字
S.isalpha()    判断字符串是否全为英文字母
S.islower()    判断字符串所有字符是否全为小写英文字母
S.isupper()    判断字符串所有字符是否全为大写英文字母
S.isspace()    判断字符串是否全为空白字符
S.center(width[,fill])    将原字符串居中，左右默认填充空格
S.count(sub[, start[,end]])    获取一个字符串中子串的个数
S.find(sub[, start[,end]])    获取字符串中子串sub的索引,失败返回-1
S.strip()    返回去掉左右空白字符的字符串
S.lstrip()    返回去掉左侧空白字符的字符串
S.rstrip()    返回去掉右侧空白字符的字符串
S.upper()    生成将英文转换为大写的字符串
S.lower()    生成将英文转换为小写的字符串
S.replace(old, new[, count])    将原字符串的old用new代替，生成一个新的字符串
S.startswith(prefix[, start[, end]])    返回S是否是以prefix开头，如果以prefix开头返回True,否则返回False,
S.endswith(suffix[, start[, end]])    返回S是否是以suffix结尾，如果以suffix结尾返回True,否则返回False
以下是不常用的    
S.title()    生成每个英文单词的首字母大写字符串
S.isnumeric()    判断字符串是否全为数字字符

空白字符
是指空格,水平制表符(\t),换行符(\n)等不可见的字符

格式化字符串中的占位符和类型码
占位符类型码    意义
%s    字符串
%r    字符串，使用repr 而不是str
%c    整数转为单个字符
%d    十进制整数
%o    八进制整数
%x    十六进制整数(字符a-f小写)
%X    十六进制整数(字符A-F大写)
%e    指数型浮点数(e小写),如2.9e+10
%E    指数型浮点数(E大写),如2.9E+10
%f, %F    浮点十进制形式
%g, %G    十进制形式浮点或指数浮点自动转换
%%    等同于一个%字符

字符串格式化表达式
  运算符
    %
  作用:
    生成一定格式的字符串
  语法:
    格式字符串 % 参数值
    格式字符串 % (参数值1, 参数值2, ...)
  格式字符串中的 % 为占位符,占位符的位置将用参数值替换

示例见:
str_fomart.py
# 此示例示意格式化表达式的用法
fmt = "姓名:_%s_, 年龄:_%d_"

name = input('请输入姓名: ')
age = int(input("请输入年龄: "))

s = fmt % (name, age)
print(s)

格式化字符串中的占位符和类型码
  占位符      意义
    %s      字符串,使用str函数转换
    %r      字符串,使用repr函数转换
    %c      整数转为单个字符
    %d      十进制整数
    %o      八进制整数
    %x      十六进制整数(a-f小写)
    %X      十六进制整数(A-F大写)
    %e      指数形浮点数(e小写)  如: 2.9e+10
    %E      指数形浮点数(E大写)  如: 2.9E+10
    %f, %F  浮点十进制形式
    %g, %G  十进制形式浮点数或指数浮点数自动转换
    %%      等同于一个%字符

占位符和类型码之间的格式语法
  格式:
    % [- + 0 宽度.精度] 类型码
  说明:
    - 左对齐(默认是右对齐)
    + 显示正号
    0 左侧空白位置补零
    宽度: 整个数据输入的宽度
    精度: 保留小数点后多少位(默认是6位)

  示例:
    '%10d' % 123   # '       123'
    '%-10d' % 123  # '123       '
    '%10s' % 'abc' # '       abc'
    '%05d' % '123' # '00123'
    '%-+5d' % 123  # '+123 '

循环语句
  问题:
    如何返回到程序的前面在继续执行
  可以用循环语句来实现

  循环语句有:
    while 语句
    for 语句

while 语句
  作用：
    根据一定条件，重复的执行一条语句或多条语句
  语法:
    while 真值表达式:
      语句块1
    else:
      语句块2
  说明:
    1. 先执行真值表达式, 测试布尔值是否为True
    2. 如果真值表达式的值为True,则执行语句1，然后再返回到第1步，重复进行测试
    3. 如果真值表达式的值为False,则执行else子句中的语句块2,然后结束此while语句，如果没有else子句，则直接结束此while语句的执行
    4. else 子句部分可以省略（同 if类似)

示例见:
while.py
# 问题:
#   输入一个整数n，根据这个整数打印n行的"hello"
n = int(input("请输入整数: "))

i = 0
while i < n: 
    print('hello')
    i += 1
else:
    print("i < n 此时为False才会执行我这一条语句")
    print("此时i=", i, "n=", n)
print("程序结束")


while 语句的注意事项:
  1. 要控制循环的真值表达式的值来防止死循环
  2. 通常用真值表达式内的循环变量来控制循环条件
  3. 通常在循环语句块内改变循环变量来控制循环的次数和变量的走向

while 语句嵌套:
  while 语句本身也是语句，和其它语句一样，可以嵌入if语句和while语句
  示意:
    while 真值表达式:
        ....
        while 真值表达式2:
            ...
        else:
            ...
    else:
       ...
示例见:
while_embed.py
# 打印 1 ~ 20 的整数， 打印在一行内
# 1 2 3 4 5 ..... 18 19 20
# 打印以上10行这样的数

# 此示例示意循环语句的嵌套
j = 0
while j < 10:
    # print("1 2 3 4 5 6 ...... ")
    # 以下是打印一行 1 2 3 4 ....
    i = 1
    while i <= 20:
        print(i, end=' ')
        i += 1
    print()  # 换行
    j += 1

break 语句
  问题:
    如果在循环过程中我不想再继续此循环语句的执行了，怎么办？
  作用:
    用于循环语句(while,for语句)中, 用来终止当前循环语句的执行
  说明:
    1. 当break语句执行后，此循环语句break之后的语句将不再执行
    2. break 语句通常和if语句组合使用
    3. break 语句终止循环时，循环语句的else子句的语句不会被执行
    4. break 语句只能终止当前循环语句的执行，如果有循环嵌套时，不会跳出嵌套的外重循环
    5. break 语句只能用在循环语句(while或for)内部使用
示例见:
break.py
# 此示例示意break语句的用法
i = 1
while i < 6:
    print("循环开始时:", i)
    if i == 3:
        break
    print("循环结束时:", i)
    i += 1
else:
    print(i, "< 6 条件不成立")

print("while 语句结束，此时i的值为:", i)

break_while_embed.py
s = 1
while s < 5:
    g = 0
    while g < 10:
        print(s, g)
        if g == 5:
            break
        g += 1
    s += 1
print("程序结束")

死循环
  死循环是指条件一直成立的循环
  死循环通常用break 语句来终止循环
  死循环的else子句永远不会执行

for 语句
  作用:
    用来遍历可迭代对象的数据元素
      可迭代对象是指能依次获取数据元素的对象
  可迭代对象包括:
    字符串str
    ----以下后再才讲----
    列表 list
    元组 tuple
    字典 dict
    集合 set
    range函数返回的对象等
  语法:
    for 变量列表 in 可迭代对象:
        语句块1
    else:
        语句块2

range 函数
  格式:
    见: >>> help(range)

  函数
    range(stop)从零开始，每次生成一个整数后加1操作，直到stop为止(不包含stop)
    range(start, stop[, step])  从start开始，每次生成一个整数后移动step, 直到stop为止(不包含stop, 且step可以是负整数)

  作用:
    用来创建一个生成一系列整数的可迭代对象(也叫整数序列生成器)
  示例:
    range(4)         # 生成 0, 1, 2, 3
    range(3, 6)      # 生成 3, 4, 5
    range(1, 10, 2)  # 生成 1 3 5 7 9
    range(5, 0, -2)  # 生成 5, 3, 1
    range(4, 0)      # 生成空

for　语句的注意事项:
  # 请问下面程序的打印结果是什么：
    i = 6
    for x in range(1, i):
        print('x =', x, 'i=', i)
        i -= 1  # <<<---注意此处
  结果:
    x = 1 i= 6
    x = 2 i= 5
    x = 3 i= 4
    x = 4 i= 3
    x = 5 i= 2  

如下语句的执行结果是什么？为什么?
  for x in range(4, 0):
      print(x)
  print('x绑定', x)  # <<<此处打印什么？

for 语句的嵌套
  示例:
    for x in "ABC":
        for y in '123':
            print(x + y)
思考：
　　for x in range(5):
     for y in range(10):
         print('hello')  # <<请问打印多少次?

问题
  如何让程序不再向下执行，重新开始一次新的循环

continue 语句
  用于循环语句(while,for语句)中，不再执行本次循环 continue之后的语句，重新开始一次新的循环

  说明:
    1. 在for 语句中执行continue语句，将会从可迭代对象中取下一个元素，绑定变量后再次开始执行
    2. 在while语句中执行continue,将会直接跳转到 while语句的真值表达式处重新判断循环条件
示例见:
continue.py
# 此示例示意contine语句的用法
for x in range(5):
    if x == 2:
        continue
    print(x)

continue2.py
# 此示例示意contine语句跳过奇数打印偶数

# 打印20以内的全部偶数
for x in range(20):
    # 判断如果x是奇数，则取下一个数
    if x % 2 == 1:
        continue
    print(x)

continue_while.py
# 此示例示意contine语句用于while语句中跳过奇数打印偶数

# 打印20以内的全部偶数
x = 0
# for x in range(20):
while x < 20:
    # 判断如果x是奇数，则取下一个数
    if x % 2 == 1:
        continue
    print(x)
    x += 1

循环语句总结:
  while 语句
      可以用于死循环
  for 语句
      用于可迭代对象的循环
        (字符串, range()返回的对象)
  break 语句:
      用于终止当前循环
  continue 语句:
      用于开始一次新的循环

列表 list
  问题:
    如何将计算机运算的数据临时存入一个地方，同时又方便添加，删除，修改等操作

列表的定义:
    列表是一种容器
    列表是序列的一种
    列表是可以被改变的序列
    列表中由一系列特定元素组成的，元素与元素之间可以没有任何的关联关系，但他们之间有先后顺序关系

创建空列表的字面值
   L = []  # L变量绑定空列表
创建非空列表的字面值
  L = [1, 2, 3, 4]
  L = ['Beijing', 'Shanghai', 'Shenzhen']
  L = [1, 'Two', 3.14, '四']
  L = [1, 2, [3.1, 3.2, 3.3], 4]

列表的构造(创建)函数 list
  list()          生成一个空的列表，等同于 []
  list(iterable)  用可迭代对象创建一个列表

示例:
  L = list()  # L绑定空列表
  L = list("hello")  # L绑定['h', 'e', 'l', 'l', 'o']
  L = list(range(1, 10, 2))
列表的运算:
  算术运算:
    +  +=  *  *= 
  + 用于拼接列表
    x = [1, 2, 3]
    y = [4, 5, 6]
    z = x + y  # z = [1,2,3,4,5,6]
  +=  用原列表与左侧列表拼接，用变量绑定拼接后的列表
    x = [1,2,3]
    x += [4,5,6]
    print(x)
  * 生成重复的列表
    x = [1, 2] * 3  # x = [1,2,1,2,1,2]
  x *= y 等同于 x = x * y

列表的比较运算:
  运算符:
    <  <=  >  >=  ==  != 
  比较的规则同字符串的规则相同
    x = [1, 2, 3]
    y = [1, 2, 4]
    x != y  # True
    x <= y  # True
    y > x   # True
    ["AB", 'abc', '123'] < ['AB', '123', 'abc']
    [1, 'two'] > ['two', 1]  # TypeError

列表的 in / not in 运算符
  作用:
    判断一个值是否存在于列表中。如果存在返回True, 否则返回False
    not in 的返回值与 in 运算符相反
  示例:
    2 in [1, 2, 3, 4]  # True
    '2' in [1, 2, 3, 4]  # False

列表是可迭代对象:
    for x in [2, 3, 5, 7]:
        print(x)  # x绑定列表内的元素

列表的索引操作:
  语法:
    列表[整数表达式]
  用法:
    等同于字符串的索引
    索引分正向索引和反向索引，规则与字符串规则完全相同
  示例:
    L = list("ABCD")
    print(L[1])  # B

列表的索引赋值
  列表是可变的，可以通过索引赋值改变列表中的元素
示例 
  L = [1, 2, 3, 4]
  L[2] = 3.1
  print(L)

列表的切片
  语法:
    列表[:]
    列表[::]
  说明:
    列表的切片取值返回一个列表,规则等同于字符串切片规则
  示例:
    x = list(range(10))
    y = x[1:9:2]  # 奇数
    y = x[::]     # 复制x列表 

列表的切片赋值
  语法:
    列表[切片slice] = 可迭代对象
  作用:
    可以改变原列表的排列，可以插入数据和修改数据
    可以用切片改变列表对应的元素的值
  说明:
    切片的赋值运算符(=)的右侧必须是一个"可迭代对象"

  示例:
    L = [2, 3, 4]
    L[1:2] = [3.1, 3.2]  # L = [2, 3.1, 3.2, 4]
    L[:1] = [1.1, 2.2]  # L=[1.1, 2.2, 3.1, 3.2, 4]
    L = [2, 3, 4]
    L[2:] = []
    L = [2, 3, 4]
    L[:0] = [0, 1]
    L = [2, 3, 4]
    L[3:] = [5, 6, 7]

    L = [2, 3, 4]
    L[1:2] = "ABC"  # L = [2, 'A', 'B', 'C', 4]
    L = [1, 2]
    L[2:] = range(3, 10)  # L = [1,2,3,4....9]

切片注意事项:
  对于步长不等1的切片赋值，赋值运算符的右侧的可迭代对象提供的数据元素的个数一定要等于切片切出的段数
  例如：
    L = [1, 2, 3, 4, 5, 6]
    L[::2] = 'ABC'  # 正确
    L[::2] = 'ABCDE' # 错误

del 语句:
  del 可以用来删除列表元素
  语法:
    del 列表[索引]
    del 列表[切片]
  示例:
    L = [1, 2, 3, 4, 5, 6]
    del L[1]
    del L[2]
    del L[-1]
    L = [1, 2, 3, 4, 5, 6]
    del L[::2]

python3中常用的序列函数
  len(x)  返回序列的长度
  max(x)  返回序列的最大值元素
  min(x)  返回序列中最小值元素
  sum(x)  返回序列中所有元素的和(元素必须是数字)
  any(x)  真值测试, 如果列表中的其中一个元素 为真值，则返回True
  all(x)  真值测试, 如果列表中的所有元素都为真值， 则返回True,否则返回False

  示例:
    L = [1, 7, 0, 3, 2]
    print(len(L))  # 5
    print(max(L))  # 7
    print(min(L))  # 0
    print(sum(L))  # 13
    print(any(L))  # True
    print(all(L))  # False

python3中常用的列表方法(method)
详见:
   >>> help(list)

文档见:
Python3中常用的列表方法（method)
方法
意义
L.index(v [, begin[, end]])
返回对应元素的索引下标, begin为开始索引，end为结束索引,当 value 不存在时触发ValueError错误
L.insert(index, obj)
将某个元素插放到列表中指定的位置
L.count(x)
返回列表中元素的个数
L.remove(x)
从列表中删除第一次出现在列表中的值
L.copy()
复制此列表（只复制一层，不会复制深层对象)
L.append(x)
向列表中追加单个元素
L.extend(lst)
向列表追加另一个列表
L.clear()
清空列表,等同于 L[:] = []
L.sort(reverse=False)
将列表中的元素进行排序，默认顺序按值的小到大的顺序排列
L.reverse()
列表的反转，用来改变原列表的先后顺序
L.pop([index])
删除索引对应的元素，如果不加索引，默认删除最后元素，同时返回删除元素的引用关系

sorted 函数:
   用于生成一个排序后的列表
   格式：
     sorted(iterable, reverse=False)

reversed(seq)  返回原序列反序的可迭代对象
示例:
  L = [7, 9, 5, 1, 3]
  L2 = sorted(L)  # L2 = [1, 3, 5, 7, 9]
  L3 = sorted(L, reverse=True)  # L3 = [9, 7, 5, 3, 1]
  for x in reversed(L):
      print(x)  # 3 1 5 9 7

字符串的文本解析方法 split 和 join方法
  S.split(sep=None)  将字符串使用sep作为分隔符分割S字符串，返回分割后的字符串列表，当不给定参数时默认用空白字符作为分隔符分割

  S.join(iterable)  用可迭代对象中提供的字符串,返回一个中间用S进行分隔的字符串

  示例:
    s = 'Beijing is capital'
    L = s.split(' ')  # L = ['Beijing', 'is', 'capital']

    L = ["C:", "Windows", "System32"]
    s = '\\'.join(L)  #s=r"C:\Windows\System32"

深拷贝 deep copy 和浅拷贝 shallow copy

浅拷贝 shallow copy
  L = [3.1, 3.2]
  L1 = [1, 2, L]
  L2 = L1.copy()  # 浅拷贝，只复制一层
  print(L1)  # [1, 2, [3.1, 3.2]]
  print(L2)  # [1, 2, [3.1, 3.2]]
  L[0] = 3.14
  print(L1)  # [1, 2, [3.14, 3.2]]
  print(L2)  # [1, 2, [3.14, 3.2]]

  说明:
    浅拷贝是指在复制过程中，只复制一层变量，不会复制深层变量绑定的对象的复制过程

深拷贝
  对所有可变对象进行层层复制,实现对象的各自独立
  例:
  import copy  # 导入复制模块
  L = [3.1, 3.2]
  L1 = [1, 2, L]
  L2 = copy.deepcopy(L1)  # 实现深拷贝
  print(L1)  # [1, 2, [3.1, 3.2]]
  print(L2)  # [1, 2, [3.1, 3.2]]
  L[0] = 3.14
  print(L1)  # [1, 2, [3.14, 3.2]]
  print(L2)  # [1, 2, [3.1, 3.2]] #此列表不受影响

列表推导式 list comprehesion
  列表推导式是用可迭代对象依次生成带有多个元素的列表的表达式

  作用：
    用简易方法生成列表
  语法:
    [表达式 for 变量 in 可迭代对象]
    或
    [表达式 for 变量 in 可迭代对象 if 真值表达式]
  示例:
    # 生成一个列表，此列表内的数值是1~9的方平
    L = [x ** 2 for x in range(1, 10)]

    # 以前的方法：
    L = []
    for x in range(1, 10):
        L.append(x ** 2)

练习:
   用列表推导式生成 1 ~ 100 内奇数的列表
   答:
     1. [x * 2 + 1 for x in range(50)]
     2. [x for x in range(1, 100, 2)]
     # 用带有if的列表推导式
       [x for x in range(100) if x % 2 ==1]
列表推导式的嵌套:
  语法:
    [表达式
      for 变量1 in 可迭代对象1 if 真值表达式1
         for 变量2 in 可迭代对象2 if 真值表达式2
            ...]
  示例:
    用字符串"ABC" 和 "123" 生成如下列表:
      ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']
    L = [x + y for x in "ABC" for y in "123"]

列表和字符串的区别:

字符串的两个方法:
   S.split('字符串')
   S.join(可迭代对象)  

元组 tuple
  元组的定义:
    元组是不可改变的序列，同list一样，元组是可以存放任意类型的容器
  元组的表示方法:
    用小括号() 括起来，单个元素括起来后加逗号(,)区分单个对象还是元组
  创建空元组的字面值
    t = ()  # t绑定空元组
  创建非空元组
    t = 200,
    t = (20,)
    t = (1, 2, 3)
    t = 100, 200, 300
  type(x) 函数用来返回 x的类型

元组的错误示例:
  t = (20)  # t 绑定定整数，不是元组
  x, y, z = 100, 200, 300  # 序列赋值等同于如下
  x, y, z = (100, 200, 300)  # 序列赋值
  x, y, z = [100, 200, 300]  # 序列赋值
  x, y, z = "ABC"            # 序列赋值

元组的构造(创建)函数 tuple
    tuple() 生成一个空的元组,等同于()
    tuple(iterable)  用可迭代对象生成一个元组
  示例:
    t = tuple()
    t = tuple([2,3,5,7])
    t = tuple(range(10))

元组的运算:
   +  加号用于元组的拼接操作
   *  乘号 用于用原元组生成重复的元组
   +=
   *=
  示例:
    t = (1, 2, 3) + (4, 5, 6)  #t=(1,2,3,4,5,6)
    t = (1, 2) * 3  # t=(1,2,1,2,1,2)

    t = (1, 2, 3)
    t += (4, 5, 6)  # 等同于字符串规则
    t *= 2  
  
元组的比较运算:
  > >= < <= == !=
    规则与列表的比较规则完全相同
  示例 
    (1, 2, 3) < (1, 3, 2)  # True
    (1, 2, 3) != (1, 3, 2)  # True
    ....
    (1, '二') < ('二', 1)

in / not in 运算符:
   与列表的in / not in 规则完全相同

   2 in (1, 2, 3, 4) # True
   '2' not in (1, 2, 3, 4)  # True

索引和切片
  索引:
    元组[整数]
  切片:
    元组[整数:整数]
    元组[整数:整数:整数]
  规则同字符串的切片规则
  元组不支持索引赋值和切片赋值

元组的方法：
  T.index(v[, begin[, end]])  返回对应元素的索引下标，begin为开始索引，end为结束索引，v不存在时触发ValueErorr错误
  T.count(x)  返回元组中对应元素的个数

序列的种类:
  字符串str, 列表list, 元组tuple,
  字节串bytes, 字节数组bytearray(后面再讲)

能用于序列的函数总结：
  len(x), max(x), min(x), sum(x), any(x),all(x)
  str(obj)  将对象转为字符串
  list(iterable) 将可迭代对象转为列表
  tuple(iterable) .........转为元组
  reversed(seq)  返回反向顺序的可迭代对象
  sorted(iteralbe, reverse=False)

字典 dict
  什么是字典
    1. 字典是一种可变的容器，可以存储任意类型的数据
    2. 字典中的每个数据都是用"键"(key) 进行索引，而不象序列可以用下标来进行索引
    3. 字典中的数据没有先后顺序关系，字典的存储是无序的
    4. 字典中的数据以键(key)-值(value)对形式进行映射存储
    5. 字典的键不能重复，且只能用不可变类型作为字典的键

  字典的字面值表示方式:
    {} 括起来，以冒号(:) 分隔键-值对, 各键-值对用逗号分隔开
  创建空字典:
    d = {}  # 空字典 
  创建非空字典:
    d = {'name':'tarena', 'age': 15}
    d = {1:'星期一', 2:"星期二"}
    # 以下写法会出现问题（因为键不能重复)
    d = {'a': 1, 'b': 2, 'a': '一'}  

  字典的构造(创建)函数 dict
    dict()    # 创建空字典，等同于 {}
    dict(iterable)  用可迭代对象初始化一个字典
    dict(**kwargs)  关键字传参形式生成一个字典
  示例:
    d = dict()
    d = dict([('name', 'tarena'), ('age', 15)])
    d = dict(name='tarena', age=15)

字典的基本操作:
  字典的键索引
    用[] 运算符可以获取和修改键所对应的值
  语法:
    字典[键]
  示例:
    d = {'name': 'tarena', 'age': 15}
    print('姓名:', d['name'], '年龄:', d['age'])
  
  添加/修改字典的元素
    字典[键] = 值

  示例:
    d = {}
    d['name'] = 'tarena'

  键索引赋值说明:
    当键不存在时，创建键并绑定键对应的值
    当键存在时，修改键绑定的对象

删除字典的元素
  del 语句 可以用来删除字典的键
  语法:
    del 字典[键]
  示例:
     d = {1:"星期一", 2:'星期二'}
     del d[2]

in 运算符(成员资格判断运算符)
  1. 可以用in运算符来判断一个键是否存在于字典中，如果存在则返回True,否则返回False
  2. not in 与 in 相反

  示例:
    d = {1: "One", 2: "Two", "三": 'Three'}
    1 in d  # True
    '二' in d  # False
    3 not in d  # True
    'One' in d  # False

字典的迭代访问:
  字典是可迭代对象，字典只能对键进行迭代访问

  示例:
    d = {1: "One", 2: "Two", "三": 'Three'}
    for k in d:
        print(k, '对应的值是:', d[k])

可以用于字典的内建(built-in)函数
  len(x)  返回字典的键值对的个数
  max(x)  返回字典的键的最大值
  min(x)  返回字典的键的最小值
  sum(x)  返回字典的键的和
  any(x)  真值测试，如果字典中的一个键为真，则结果为真
  all(x)  真值测试，字典中所有键为真，则结果才为真

字典的方法:
  文档见: 
字典的方法(可能需要重新整理)
函数
说明
D代表字典对象

D.clear()
清空字典
D.pop(key)
移除键，同时返回此键所对应的值
D.copy()
返回字典D的副本,只复制一层(浅拷贝)
D.update(D2)
将字典 D2 合并到D中，如果键相同，则此键的值取D2的值作为新值
D.get(key, default)
返回键key所对应的值,如果没有此键，则返回default

D.keys()
返回可迭代的 dict_keys 集合对象
D.values()
返回可迭代的 dict_values 值对象
D.items()
返回可迭代的 dict_items 对象

  示例:
    d = {1:'One', 2:'Two', 3:'Three'}
    for k, v in d.items():
        print("字典的键是:", k, '值是:', v)

字典推导式
  字典推导式是用可迭代的对象依次生成字典的表达式

  语法:
    { 键表达式: 值表达式 for 变量 in 可迭代对象 [if 真值表达式]}
    注: [] 及其中的内容代表可省略
  说明:
    1. 先从可迭代对象中取值
    2. 用变量绑定
    3. 用if 进行条件判断，如果为真值则执行下一步
    4. 执行'键表达式'和 '值表达式' 然后加入到新字典中
  示例:
    生成一个字典，键为1~9的整数,值为键的平方
    d = {x: x **2 for x in range(1, 10)}

练习:
  有如下字符串：
    L = ['tarena', 'china', 'beijing']
  生成如下字典:
    D = {'tarena': 6, 'china':5, 'beijing':7}
  答:
    D = {x: len(x) for x in L}

练习2:
  No = [1001, 1002, 1005, 1008]
  names = ['Tom', 'Jerry', 'Spike', 'Tyke']
  用上面No列表中的数据作为键，用names中的数据作为值，生成相应的字典:
    如:
    d = {1001: 'Tom', 1002: 'Jerry', ....}

  方法1:
    d = {No[i]: names[i] for i in range(len(No))}
  方法2:
    d = {n: names[No.index(n)] for n in No}
字典推导式可以嵌套，语法同列表推导式

字典 vs 列表
  1. 都是可变对象
  2. 索引方式不同,列表用整数索引，字典用键索引
  3. 字典的查找速度可能会快于列表(重要)
  4. 列表的存储是有序的，字典的存储是无序的

列表 和字典 的内部存储原理
  列表，顺序存储
  字典，映射存储

元组:
  所有的序列都有相同的操作:
    + += * *= 
    < <= > >= == !=
    in / not in 
    索引 index/ 切片 slice
        列表可以索引赋值和切片赋值

字典 dict
  键-值对(key-value)对
  字典的无序的，可变的容器

键索引
  字典[键key]

  del 语句可以删除字典的'键'

  in / not in 运算符

内建函数:
  len(x) max(x), min(x) .....

字典的方法:
  D.clear()
  D.pop(key)  删除键
  D.copy()
  D.update(d2)  合并字典
  D.get(key, default)
  D.keys()
  D.values()
  D.items()  
  详见:
    >>> help(dict)
字典推导式:
  { key表达式: value 表达式
       for 变量 in 可迭代对象 if 真值表达式
           for 变量2 in 可迭代对象2 if 真值表达式2
               ....
  }

集合 set
  集合是可变的容器
  集合内的数据对象都是唯一的（不能重复多次的)
  集合是无序的存储结构，集合中的数据没有先后顺序关系
  集合内的元素必须是不可变的对象
  集合是可迭代对象
  集合是相当于只有键没有值的字典（键则是集合的数据）

创建空的集合:
  set()
创建非空集合:
  s = {1, 2, 3}

集合的构造(创建)函数 set
  set()  创建一个空的集合对象(不能用{}来创建空集合)
  set(iterable)  用可迭代对象创建一个新的集合

示例:
  s = set()   # 空集合
  s = {1,2,3,4} 
  s = set("ABC")  # s = {'A', 'B', 'C'}
  s = set("ABCCBA")  # s = {'A', 'B', 'C'}
  s = set({1:"一", 2:"二", 5:"五"})  # s={1,2,5}
  s = set([1, 2, 3, 2])  # s = {1,2,3}


集合的运算:
  交集， 并集， 补集， 子集，超集，对称补集
   &     |     -     <    >     ^

＆ 生成两个集合的交集
    s1 = {1, 2, 3}
    s2 = {2, 3, 4}
    s3 = s1 & s2  # s3 = {2, 3}

|  生成两个集合的并集
    s1 = {1, 2, 3}
    s2 = {2, 3, 4}
    s3 = s1 | s2  # s3 = {1, 2, 3, 4}

-  生成两个集合的补集
    s1 = {1, 2, 3}
    s2 = {2, 3, 4}
    s3 = s1 - s2  # s3 = {1} 生成属性s1但不属性 s3的所有元素的集合
    s4 = s2 - s1  # s4 = {4}

^  对称补集
    s1 = {1, 2, 3}
    s2 = {2, 3, 4}
    s3 = s1 ^ s2  # s3 = {1, 4}

> 判断一个集合是另一个集合的超集
< 判断一个集合是另一个集合的子集
   s1 = {4, 5, 6}
   s2 = {4, 5}
   s1 > s2  # True  s1是s2的超集
   s2 < s1  # True  s2是s1的子集

== != 判断集合是否相同
  {1, 2, 3}  == {2, 3, 1}  # True
  {1, 2}  != {3, 4}  # True

<=  >= 判断包含，被包含关系

in / not in 运算符
  in判断一个元素是否存在于集合中(同其它容器类型的in 相同)
  not in 与 in相反

集合和字典的优点:
  in / not in运算符的查找速度快

集合的内建函数操作:
  len(x), max(x), min(x), sum(x), any(x), all(x) 

python3 中常的集合方法:
  详见：
Python3 集合中常用的方法
方法
意义
S.add(e)
在集合中添加一个新的元素e；如果元素已经存在，则不添加
S.remove(e)
从集合中删除一个元素，如果元素不存在于集合中，则会产生一个KeyError错误
S.discard(e)
从集合S中移除一个元素e,在元素e不存在时什么都不做;
S.clear()
清空集合内的所有元素
S.copy()
将集合进行一次浅拷贝
S.pop()
从集合S中删除一个随机元素;如果此集合为空，则引发KeyError异常
S.update(s2)
用 S与s2得到的全集更新变量S

S.difference(s2)
用S - s2 运算，返回存在于在S中，但不在s2中的所有元素的集合
S.difference_update(s2)
等同于 S = S - s2
S.intersection(s2)
等同于 S & s2
S.intersection_update(s2)
等同于S = S & s2
S.isdisjoint(s2)
如果S与s2交集为空返回True,非空则返回False
S.issubset(s2)
如果S与s2交集为非空返回True,空则返回False
S.issuperset(...)
如果S为s2的子集返回True,否则返回False
S.symmetric_difference(s2)
返回对称补集,等同于 S ^ s2
S.symmetric_difference_update(s2)
用 S 与 s2 的对称补集更新 S
S.union(s2)
生成 S 与 s2的全集

集合是可迭代对象
  用for语句可以得到集合中的全部数据元素
    s = {1, "二", 3.14, "Four"}
    for x in s:
        print(x)

集合推导式:
  集合推导式是用可迭代对象生成集合的表达式

  语法：
    {表达式 for 变量 in 可迭代对象 [if 真值表达式]}
    注:[] 括起的部分代表可省略

推导式内的 for 子句可以嵌套

固定集合 frozenset
  固定集合是不可变的，无序的，含有唯一元素的集合

  作用:
    固定集合可以作为字典的键，也可以作为集合的值

  创建空的固定集合:
    fz = frozenset()
  创建非空的固定集合:
    frozenset(iterable)  用可迭代对象创建集合
    例:  fz = frozenset([2, 3, 5, 7])

固定集合的运算:
   同set运算完全一致
   & 交集, | 并集, - 补集， ^ 对称补集, 
   > >= < <= == !=
   in , not in 

固定集合的方法:
  相当于集合的全部方法去掉修改集合的方法



总结:
  数据类型:
    不可变的类型:
      bool, int, float, complex, str, tuple, frozenset, bytes(后面会讲)
    可变的数据类型:
      list, dict, set, bytearray
  值:
    None, False, True

运算符:
  + - * /  // % **
  >  >=  <  <=  ==  !=
  not  and  or
  in, not in
  & | ^ 
  +(正号) -(负号)

表达式:
  100
  100 + 200
  len([1,2,3]) + max([1,2,3])  # 函数调用是表达式
  print("hello")
  条件表达式: x if x > y else y
  全部的推导式: [x for x in range(5)]
       (列表，字典，集合推导式三种)

语句 statement
  表达式语句:
     print("hello world")
     'hello'
  赋值语句:
    a = 100
    a = b = c = 200
    x, y, z = 100, 200, 300
  if 语句
  while 语句
  for 语句
  break 语句
  continue 语句
  pass 语句
  del 语句

内建函数:
  len(x)
  max(x)
  min(x)
  sum(x)
  any(x)
  all(x)
构造函数:
  bool(x)
  int(x, base=10)
  float(x)
  complex(real=0, image=0)
  str(x)
  list(x)
  tuple(x)
  dict(x)
  set(x)
  frozenset(x)

数字处理函数:
  abs(x)
  round(x)
  pow(x, y,z=0)

字符串相关函数:
  bin(x)
  oct(x)
  hex(x)
  chr(x)
  ord(x)
迭代器相关:
  range(start, stop, step)
  reversed(x)
  sorted(x)
输入输出相关:
  input(x)
  print(...)
详见:
  >>> help(__builtins__)



函数 function
  什么是函数:
    函数是可以重复执行的语句块, 可以重复调用
  作用：
    用于封装语句，提高代码的重用性
    用于定义(创建)用户级别的函数
  语法:
    def 函数名(形参列表):
        语句块

  说明:
    1. 函数的名字就是语句块的名称
    2. 函数名的命名规则与变量名相同（函数名必须是标识符)
    3. 函数名是一个变量函数名是一个变量
    4. 函数有自己名字空间，在函数外部不可以访问函数内部的变量，在函数内部可以访问函数外部的变量,要让函数处理外部数据需要用参数给函数传入一些数据
    5. 参数列表可以为空
    6. 语句部分不能为空，如果为空需要用pass语句填充
示例见:
function1.py
def say_hello():
    print("hello world!")
    print("hello tarena!")
    print("hello overyone!")

# 调用函数:
say_hello()
say_hello()
say_hello()

函数调用:
  函数名(实际调用传递参数)

  说明:
    函数调用是一个表达式
    如果没有return 语句，函数执行完毕后返回None对象
    如果函数需要返回其它的对象需要用到return语句
  
示例见:
mymax.py
# 此示例示意函数的传参:
# 此函数用于打印调用者传给我们的实参的最大一个
def mymax(a, b):
    # print("用户传给我的第一个参数a是", a)
    # print("b =", b)
    if a > b:
        print("最大的是: ", a)
    else:
        print("最大的是:", b)

# 调用mymax
mymax(100, 200)
mymax(5, 3)

问题:
   def mysum(a, b):
       print(a + b)
    
   r = mysum(100, 200)
   print(r)  # 请问r绑定的是什么？
  # 让mysum返回一个加法的结果:
   def mysum(a, b):
       result = a + b

   r = mysum(100, 200)
   print(result) # 打印错误
函数说明:
    函数外部无法访问函数内部的局部变量
    函数内部可以访问函数外部的变量,但不能修改函数外部变量的绑定关系
    例如:
      x = 0
      def myadd(a, b):
          x = a + b
          print(x)
      r = myadd(100, 200)
      print(x)  # 0

return 语句
  语法:
    return [表达式]
    注: [] 代表内容可省略
  作用:
    用于函数中,结束当前的函数的执行,返回到调用该函数的地方,同时返回表达式的引用关系
  说明:
    1. return语句后跟的表达式可以省略,省略后相当于return None
    2. 如果函数内没有return语句,则函数执行完最后一条语句后返回None(相当于在最后加了一条 return None语句)

示例见:
return.py
def say_hello():
    print("1")
    print("2")
    return "你好"
    print("3")

r = say_hello()
print(r)  # None
# say_hello()

函数的参数传递
  传递方式:
    位置传参
      序列传参
    关键字传参
      字典关键字传参

位置传参:
    实际传递参数(以下简称"实参")与形式参数(形参)的对应关系按位置来依次对应
示例见:
position_give_args.py
# 此示例示意位置传参
def myfun(a, b, c):
    """注意此函数不会变化"""
    print('a =', a)
    print('b =', b)
    print('c =', c)
myfun(1, 2, 3)

序列传参:
  序列传参是指在函数调用过程中用"*"将序列拆解后按位置进行传递的传参方式

示例见:
sequence_give_args.py
# 此示例示意序列传参
def myfun(a, b, c):
    """注意此函数不会变化"""
    print('a =', a)
    print('b =', b)
    print('c =', c)

s = "ABC"
L = [4,5,6]
t = (1.1, 2.2, 3.3)

# myfun(s[0], s[1], s[2])  # 按位置传
myfun(*s)
myfun(*L)
myfun(*t)

关键字传参:
  关键字传参是指传参时,按着形参的"名称"给形参赋值
    实参和形参按名称进行匹配
示例见:
keyword_give_args.py
# 此示例示意关键字传参
def myfun(a, b, c):
    """注意此函数不会变化"""
    print('a =', a)
    print('b =', b)
    print('c =', c)

myfun(b=2, c=3, a=1)
myfun(c=333, b=222, a=111)

# 以下是错误的
# myfun(a=2, c=3, a=1)
# myfun(d=2, c=3, a=1)

字典关键字传参:
  是指实参为字典,将字典用 "**" 拆解后进行关键传参的传参方式
示例见:
dict_keywork_give_args.py
# 此示例示意字典关键字传参
def myfun(a, b, c):
    """注意此函数不会变化"""
    print('a =', a)
    print('b =', b)
    print('c =', c)

d = {'a':111, 'c':333, 'b': 222}
myfun(**d)  # 等同于 myfun(a=111,c=333,b=222)

# 以下是错误传法
# d2 = {1: '一', 'c':333, 'b': 222}
# myfun(**d2)

  说明:
    字典的键名和形参名必须一致
    字典的键名必须为字符串(且必须为标识符的规则)
    字典的键名要在形参中存在

函数的综合传参:
  函数的传参方式在能确定形参能唯一匹配到应当实参的情况下可以任意组合
  要求:
    位置传参在前,关键字传参在后
示例见:
com_give_args.py
# 此示例示意 函数的组合 传参
def myfun(a, b, c):
    """注意此函数不会变化"""
    print('a =', a)
    print('b =', b)
    print('c =', c)

# myfun(1, c=3, b=2)  # 正确
# myfun(b=2, a=1, 3)  # 错的
myfun(100, *[200, 300])  # 正确 
myfun(*"AB", 300)  # 正确
myfun(*[100], c=300, b=200)  # 正确
myfun(*"AB", **{"c":300})  # 正确


---------以下为函数的定义和创建时形参的定义--------
函数的缺省参数
  语法
    def 函数名(形参名1=默认实参1, 形参名2=默认实参2, ..)

示例见:
defualt_args.py
# 此程序示意函数的缺省参数
def info(name, age=1, address="未填写"):
    print(name, "今年", age, "岁, 住在:", address)

# info()  # 出错,至少得给一个实参给name绑定
info('小李')
info('tarena', 15)
info('小魏', 3, '北京市朝阳区')

  说明:
    1. 缺省参数必须自右至左依次存在,如果一个参数有缺省参数,则其右侧的所有参数都必须有缺省参数
       def fa(a=1, b, c=3):  # 是错的
       def fb(a, b=10, c):   # 是错的
    2. 缺省参数可以有0个或多个,甚至全部都是缺参参数

函数形参的定义方式:
  位置形参
  星号元组形参
  命名关键字形参
  双星号字典形参

位置形参:
  语法:
    def 函数名(形参名1, 形参名2, ...):
        语句块 

星号元组形参:
  语法:
    def 函数名(*元组形参名):
       语句块
  作用:
    收集多余的位置传参

命名关键字形参
  语法:
    def 函数名(*, 命名关键字形参):
        语句块
    或
    def 函数名(*args, 命名关键字形参):
        语句块
  作用:
    强制所有的传参都必须用关键字传参
示例见:
keywords_args.py
# 此示例示意函数的命名关键字形参
def fa(a, b, *, c, d):
    '''强制c,d必须用关键字传参 '''
    print(a, b, c, d)

fa(1, 2, d=400, c=300)  # 对的

def fb(a, b, *args, c, d):
    print(a, b, args, c, d)

fb(1, 2, 3, 4, d=400, c=200)
fb(1,2,3,4,5, **{'d':400, 'c':300})

# 问题:
# fb(1,2,3,4, c=400, d=300, e=500)  # 出错,e是多余的

# fa(1, 2, 3, 4)  # 错的

双星号字典形参
  语法:
    def 函数名(**字典形参名):
        语句
  作用:
    收集多余的关键字传参
示例见:
double_start_keyword_args.py
# 此示例示意双星号字典形参的用法
def fa(**kwargs):
    '''kwargs绑定字典'''
    print("多余的关键字传参的个数是:", len(kwargs))
    print("kwargs =", kwargs)

fa(a=10, b=20, c=30)

def fb(*args, a, **kwargs):
    print(args, a, kwargs)

fb(1,2,3, b=20, c=30, a=10)

函数的参数说明:
  位置形参, 星号元组形参,命名关键字形参,双星号字典形参,缺省参数可以混合使用

函数参数自左至右的顺序依次为:
  位置形参
  星号元组形参
  命名关键字形参
  双星号字典形参

示例:
  def fn(a, b, *args, c, d, **kwargs):
      pass
  fn(1,2,3,4, c=100, d=200, e=300, f=400)

局部变量:
  1. 定义在函数内部的变量称为局部变量(函数的形参也是局部变量)
  2. 局部变量只能在函数内部使用
  3. 局部变量在函数调用时才能够被创建,在函数调用结束之后会自动销毁
全局变量:
  1. 定义在函数外部,模块内部的变量称为全局变量
  2. 所有的函数都可以直接访问"全局"变量,但函数内部不能直接通过赋值语句来改变全局变量

示例见:
variable.py
a = 100
b = 200

def fx(c):
    print('hello')
    d = 400
    a = 10  # 此赋值语句在函数,它只能创建局部变量,不能改变全局变量
    print(a, b, c, d, sep='  => ')

print('a =', a, 'b =', b)
fx(300)
print('a =', a, 'b =', b)
# print(c)  # 局部变量只能在函数内部使用

局部变量说明:
  1. 在函数内首次对变量赋值是创建局部变量,再次为变量赋值是修改局部变量的绑定关系
  2. 在函数内部的赋值语句不会对全局变量造成影响
  3. 局部变量只能在其被声明的函数内部访问,而全局变量可以在整个模块同访问

练习:
  创建一个全局变量:
  L = []
  写一个函数:
  def input_number():
      读入正整数 放到L列表内

  # ......   input_number()  # 输入1 2 3
  print(L)  # [1, 2, 3]
  # ..... input_number()  # 输入4, 5
  print(L)  # [1, 2, 3, 4, 5]



globals() 函数和locals 函数
  globals() 返回当前全局作用域内变量的字典
  locals()  返回当前局部作用域内的变量的字典
示例见:
globals_locals_function.py
# 此示例示意globals() 函数和 locals函数的用法
a = 1
b = 2
c = 3
def fx(c, d):
    e = 300
    # 此处有几个局部变量?
    print('locals() 返回', locals())
    print("globals() 返回", globals())
    print(c)  # 100
    print(globals()['c'])  # 3
fx(100, 200)

函数变量
  函数名是变量,它在创建时绑定一个函数

示例见:
function_variable.py
def f1():
    print("hello f1")

def f2():
    print("hello f2")

fx = f1  # 注意此处f1没有加()
fx()  # 调用f1
f1()  # 调用f1
f1 = f2  # 让f1 改变绑定关系,去绑定f2
f1()  # 调用f2
f2 = fx
f2()  # 调用f1  # 交换法(三次交换赋值)

一个函数可以作为另一个函数实参传递

示例:
  def f1():
      print("f1被调用")

  def f2():
      print("f2被调用")

  def fx(fn):
      print("fn绑定的是: ", fn)
      fn()  # 调用fn绑定的函数, 此处等同于调用谁呢?

  fx(f1)
  fx(f2)

案例:
  看懂如下代码做什么事?

  def myinput(fn):
      L = []
      while True:
          x = int(input("请输入大于0的整数:") or '-1')
          if x < 0:
              break
          L.append(x)
      return fn(L)  # <<< 注意此处

  print(myinput(max))
  print(myinput(min))
  print(myinput(sum))

函数作为另一个函数的返回值
  
示例见:
function_return_other_function.py
# 此示例示意get_op这个函数可以返回其它的函数
def get_op():
    s = input("请输入您要做的操作: ")
    if s == '求最大':
        return max
    elif s == '求最小':
        return min
    elif s == '求和':
        return sum

L = [1, 2, 3, 4]
fx = get_op()
print( fx(L) )

函数的嵌套定义
  函数嵌套定义是指一个函数里用def 语句来创建其它函数的情况

示例见:
function_embed_def.py
# 此示例示意函数内部来嵌套定义其它函数
def fun_outer():
    print("fun_outer被调用...")
    # 在此处创建另一个函数,并在下面调用
    def fun_inner():
        print("fun_inner被调用")
    fun_inner()  # 调用一次
    fun_inner()  # 调用二次...

    print("fun_outer调用结束")

fun_outer() # 调用函数

# fun_inner()  # 调用失败

python 的作用域
  作用域也叫命名空间,是访问变量时查找变量名的范围空间

python的四个作用域  LEGB
  作用域               英文解释              英文简写
局部作用域(函数内)  Local(function)            L
外部嵌套函数作用域  Enclosing function locals  E
函数定义所在模块(文件)的作用域 Globals(module)  G
python 内置模块的作用域 Builtin(python)        B

示例见:
namespace.py
# 此示例示意 python的四个作用域
v = 100
def fun1():
    # v = 200
    print('fun1.v = ', v)
    def fun2():
        # v = 300
        print('fun2.v=', v)

    fun2()

fun1()
print("全局的v=", v)

变量名的查找规则:
  1. 在访问变量时先查找本地变量,然后是包裹此函数外部的函数内部的变量,之后是全局变量,最后是内置(内建)变量
      L --->  E  ---> G ---> B
  2. 在默认情况下,变量名赋值会创建或者改变本地作用域变量

问题:
  v = 100
  def change_v(a):
      v = a  #  请问能修改全局的v吗?

  change_v(200)

global 语句
  作用:
    1. 告诉解释器, global语句声明的一个或多个变量,这些变量的作用域为模块级的作用域(也称作全局变量)
    2. 全局声明(global) 将赋值的变量映射到模块文件内部的作用域
  语法:
    global 变量1, 变量2, ...
  示例:
    global v, a, b, c
    global d
示例见:
global.py
# 此示例示意globals 声明
v = 100
def fn():
    # 添加全局声明,告诉解释执行器,本函数内的变
    # 量v为全局变量
    global v
    v = 200  # 本意想要修改全局变量v让它绑定200
fn()
print("v =", v)

  global说明
    1. 全局变量如果要在函数内部被赋值,则必须经过全局 声明(否则会被认为是局部变量)
    2. 全局变量在函数内部不经过声明就可以直接访问
    3. 不能先创建局部变量,再用global声明为全局变量,此做法不附合规则
    4. global变量列表里的变量名不能出现在此作用域内形参列表里

nonlocal 语句
  作用:
    告诉解释器,nonlocal声明的变量不是局部变量,也不是全局变量,而是外部嵌套函数内的变量

  nonlocal的语法
    nonlocal 变量名1, 变量名2, ...
示例见:
nonlocal.py
var = 100
def f1():
    var = 200
    print("f1里的var=", var)
    def f2():
        nonlocal var  # 声明var为f2以外,全局变量以内的变量
        var = 300

    f2()
    print('f1调用结束时var=', var)

f1()
print("全局的var=", var)

  说明:
    1. nonlocal 语句只能在被嵌套的函数内部进行使用
    2. 访问nonlocal变量将对外部嵌套函数作用域内的变量进行操作
    3. 当有两层或两层以上函数嵌套时,访问nonlocal变量只对最近一层的变量进行操作
    4. nonlocal语句的变量列表里的变量名,不能出现在此函数参数列表中

问题:
  请问 'def 语句' 干什么用的?

lambda 表达式(又称匿名函数)
  作用:
    创建一个匿名函数对象
    同 def 类似,但不提供函数名
  语法格式:
    lambda [形参1, 形参2, ...] : 表达式
示例见:
lambda.py
# 此示例示意用lambda创建匿名函数
# def myadd(a, b):
#     return a + b

myadd = lambda a, b: a + b  # 表达式

print("10 + 20 =", myadd(10, 20))
print("30 + 40 =", myadd(30, 40))

  说明:
    1. lambda 只是一个表达式,它用来创建一个函数对象
    2. 当lambda表达式调用时,先执行冒号(:)后的表达式,并返回表达式的结果的引用
    3. lambda 表达式创建的函数只能包含一条表达式
    4. lambda比函数简单且可以随时创建和销毁,有利于减少程序的偶合度

eval 和 exec 函数:

eval 函数:
  作用:
    把一个字符串当成一个表达式来执行,返回表达式执行后的结果
  格式:
    eval(source, globals=None, locals=None)
示例见:
eval.py
# s = input("请输入表达式:")  # 输入100 + 200 * 300
# v = eval(s)  # 等同于 v = 100 + 200 * 300
# print("您输入的表达式经过eval执行后结果为", v)

x = 100
y = 200
while True:
    s = input("请输入表达式 >>> ")
    if not s:
        break
    v = eval(s)
    print(v)

eval2.py
# 此示例示意eval的用法:
x = 100
y = 200
v = eval('x + y')
print(v)  # 300

dict_local = {'x':1, 'y': 2}
v = eval('x + y', None, dict_local)
print(v)  # 3

dict_global = {'x':10, 'y': 20}
v = eval('x + y', dict_global, {'y':2})
print(v)  # 12


v = eval('x + y', None, {'y':2})
print(v)  # 12

v = eval('x + y', {'x':1})
print(v)  # 1 + y 出错

exec函数:
  作用:
    把一个字符串当成'程序'来执行
  格式:
    exec(source, globals=None, locals=None)
示例见:
exec.py
# 此示例示意exec函数的使用
x = 100
y = 200
s = '''z=x+y
print('z=', z)
print("hello world!")
'''
exec(s)  # 执行 s这个字符串
print(z)

dict_local = {'x': 1}
exec(s, None, dict_local)
print(dict_local)

函数式编程
   是指用一系列函数解决问题

函数是一等公民(Guido)
  1. 函数本身可以赋值给变量,赋值后变量绑定函数
  2. 允许将函数本身作为参数传入另一个函数
  3. 允许函数返回一个函数

好处:
  用每一个函数完成细小的功能,一系列函数在任意组合可以完成大问题

函数的可重入性:
  当一个函数在运行时不读取和改变除局部作用域以外的变量时,此函数为可重入函数

  可重入函数在每次调用时,如果参数一定,则结果必然一定

示例:
  可重入函数:
    def add1(x, y):
        return x + y
    
  不可重入函数示例:
    y = 200
    def add2(x):
        return x + y
    print(add2(10))  # 210
    y = 300
    print(add2(10))  # 310



高阶函数 high order function
  什么是高阶函数
    满足下列条件中一个的函数即为高阶函数
      1. 函数接收一个或多个函数作为参数传入
      2. 函数返回一个函数

python中内建的高阶函数:
  map, filter, sorted

map 函数
  map(func, *iterables) 用函数和对可迭代对象中的每一个元素作为参数返回新的可迭代对象.当最短的一个可迭代对象不再提供数据时迭代结束
    要求:
      func函数接收的参数个数必须与可迭代对象的个数相同
示例见:
map.py
def power2(x):
    return x ** 2

# 生成一个可迭代对象,此可迭代对象可以生成1~9的自然数的平方
for x in map(power2, range(1, 10)):
    print(x)

print('=================================')
L1 = [1, 2, 3, 4]
L2 = [5, 6, 7, 8, 9, 10]
# 生成一个可迭代对象,此可迭代对象生成的数据为:
#    1**5, 2**6, 3**7, 4**8
def power_x_y(x, y):
    return x + y

for x in map(power_x_y, L1, L2):
    print(x)  # ...

filter 函数:
  格式:
    filter(function, iterable)
  作用:
    筛选可迭代对象iterable中的数据,返回一个可迭代对象,此可迭代对象将对iterable提供的数据进行筛选
  说明:
    函数function 将对iteralbe中的每个元素进行求布尔值,返回True则保留,返回False则丢弃
示例见:
filter.py
def isodd(x):  # 此函数判断x是否为奇数,如果是奇数返回True
    return x % 2 == 1

for x in filter(isodd, range(41, 53)):
    print(x)

sorted 函数
  作用:
    将原可迭代对象提供的数据进行排序，生成排序后的列表
  格式:
    sorted(iterable, key=None, reverse=False)
  说明:
    iterable 可迭代对象
    key 函数是用来提供一个排序参考值的函数，这个函数的返回值将作为排序的依据
    reverse 标志用来设置是否降序排序
  示例:
    L = [5, -2, -4, 0, 3, 1]
    L2 = sorted(L)  # [-4, -2, 0, 1, 3, 5]
    # 要得到这样的结果该怎么办？
    L3 = sorted(L, key=abs)  # [0, 1, -2, 3, -4, 5]

    names = ['Tom', 'Jerry', 'Spike', 'Tyke']
    # 结果 ['Tom', 'Tyke', 'Jerry', 'Spike']
    L = sorted(names, key=len)

递归函数 recursion
  函数直接或间接的调用自身

示例:
  def f():
      f()  # 直接调用自己，进入递归
  f()
  # 函数间接调用自身
  def fa():
      fb()
  def fb():
      fa()
  fa()
  print("递归完成")

说明：
  递归一定要控制递归的层数，当符合一定条件时要终止递归调用 
  几乎所有的递归都能用while循环来代替

优点:
  递归可以把问题简单化，让思路更为清晰,代码更简洁
缺点:
  递归因系统环境影响大，当递归深度太大时，可能会得到不可预知的结果

递归的两个阶段：
  递推阶段:  从原问题出发，按递归公式递推从未知到已知，最终达到递归的终止条件
  回归阶段: 按递归终止条件求出结果，逆向逐步代入递归公式，回归到问题求解

示例见:
recursion.py
def fn(n):
    print("递归进入第", n, '层')
    # 当递归进入第三层时，将不再向下走，开始回归
    if n == 3:
        return
    fn(n + 1)
    print('递归退出第', n, '层')

fn(1)
print("程序结束")

示例见:
recursion_factorial.py
# 写一个函数求n的阶乘（递归实现）
#   1 * 2 * 3 * 4 * 5
#   等同于
#   5 * 4 * 3 * 2 * 1
#   5! = 5 * 4!
#   5! = 5 * 4 * 3!
#   5! = 5 * 4 * 3 * 2!
#   5! = 5 * 4 * 3 * 2 * 1!
#  回归
#   5! = 5 * 4 * 3 * 2
#   5! = 5 * 4 * 6
#   5! = 5 * 24
#   5! = 120

def myfac(n):
    if n == 1:
        return 1
    return n * myfac(n-1)

print('5的阶乘是:', myfac(5))

递归的实现方法
  先假设函数已经实现

闭包 closure
  闭包是指引用了此函数外部嵌套函数作用域变量的函数

闭包必须满足三个条件:
  1. 必须有内嵌函数
  2. 内嵌函数必须引用外部函数中的变量
  3. 外部函数返回值必须是内嵌函数.

示例见:
closure.py
# 问题:
# 如何写一个函数，让此函数能过调用参数y就
#  能生成一个x的y次方的函数

# def make_power(y):
#     if y == 1:
#         def fn(x):
#             return x ** 1
#         return fn
#     if y == 2:
#         def fn(x):
#             return x ** 2
#         return fn
#     if y == 3:
#         def fn(x):
#             return x ** 3
#         return fn
#     if y == 4:
#         def fn(x):
#             return x ** 4
#         return fn
#     if y == 5:
#         def fn(x):
#             return x ** 5
#         return fn

def make_power(y):
    def fn(x):
        return x ** y
    return fn

pow2 = make_power(2)
print('5的平方是:', pow2(5))

pow3 = make_power(3)
print("6的立方是", pow3(6))

# pow100 = make_power(100)
# print("2的100次方是:", pow100(2))

# 计算
 # 1** 2 + 2**2 + 3**2 + ..... + 9 ** 2
print(sum(map(lambda x: x**2, range(1, 9))))
print(sum(map(make_power(2), range(1, 9))))

装饰器 decorators

问题:
  函数名是变量，它绑定一个函数
  函数名 /  函数名()  区别

什么是装饰器
  装饰器是一个函数，主要作用是用来包装另一个函数或类(后面会讲)
  作用：
    是在不改变原函数名(或类名)的情况下改变被包装对象的行为
函数装饰器:
  函数装饰器是指装饰器是一个函数，传入的是一个函数，返回的也是一个函数

语法:
    def 装饰器函数名(参数):
        语句块
        return 函数对象

    @装饰器函数名<换行>
    def 函数名(形参列表):
        语句块
示例见:
mydeco1.py
def mydeco(fn):
    def fx():
        print("fx函数被调用")
    return fx

# myfunc加了mydeco装饰器，等同于在myfunc创建之后调用
# myfunc = mydeco(myfunc)
@mydeco
def myfunc():
    print("函数myfunc被调用")

# 这样的写法可以用装饰器来代替
# 等同于
#   @mydeco
#   def myfunc()....

# myfunc = mydeco(myfunc)

myfunc()  # 这里调用谁?

mydeco2.py
def mydeco(fn):
    def fx():
        print("++++++++这是myfunc调用之前++++++++")
        # 要想在此处调用被装饰的函数myfunc怎么办？
        fn()  # 调用被装饰函数
        print("--------这是myfunc调用之后--------")
    return fx

@mydeco
def myfunc():
    print("函数myfunc被调用")

myfunc()  # 这里调用谁?

mydeco3.py
def myfunc():
    print("++++++++这是myfunc调用之前++++++++")
    print("函数myfunc被调用")
    print("--------这是myfunc调用之后--------")

myfunc()  # 这里调用谁?

看懂下面代码的调用关系及打印结果
  def mydeco(fn):
      print('装饰器函数被调用了....')
      def fx():
          print('fx被调用')
      return fx

  @ mydeco  # 这里加装饰器和不加装饰器结果一样吗？为什么？
  def myfunc():
      print('函数myfunc被调用')

  myfunc()
  myfunc()  # 调用第二次
  myfunc()  # 调用第三次

函数的文档字符串
  函数内第一次未赋值给任何变量的字符串是此函数的文档字符串

  语法:
    def 函数名(形参列表):
        '''函数的文档字符串'''
        函数语句块
  示例:
    def hello():
        '''此函数用来打招呼...
        这是函数的文档字符串
        '''
        pass
    >>> help(hello)
  说明:
    1. 文档字符串通常用来说明本函数的功能和使用方法
    2. 在交互模式下，输入:help(函数名) 可以查看函数的文档字符串

函数的 __doc__ 属性
  __doc__ 属性用于记录文档字符串

函数的 __name__ 属性
  __name__ 用于记录函数的名称

函数的定义语法:
  @装饰器1
  @装饰器2
  ...
  def 函数名(位置形参, *元组形参(或*), 命名关键字形参, **字典形参):
      '''文档字符串'''
      语句块

面试题,思考？
L = [1, 2, 3]
def f(n=0, lst=[]):
     lst.append(n)
     print(lst)

f(4, L)  # 打印结果是什么？ [1, 2, 3, 4]
f(5, L)  # 打印结果是什么？ [1, 2, 3, 4, 5]
f(100)  [100]
f(200)  # 打印结果是什么？为什么？  [100, 200]

如下代码的打印结果是什么？
L = [1, 2, 3]
def f(n=0, lst=None):
     if lst is None:
        lst = []
     lst.append(n)
     print(lst)

f(4, L)  # 打印结果是什么？·[1, 2, 3, 4]
f(5, L)  # 打印结果是什么？ [1, 2, 3, 4, 5]
f(100)  #[100]
f(200)  # 打印结果是什么？为什么？  [200]

模块 Module
  什么是模块
    模块是一个包含有一系列数据，函数，类等组成的程序组
    模块是一个文件，模块文件名通常以'.py'结尾
  
  模块的作用:
    1. 让一些相关的数据，函数,类等有逻辑的组织在一起，使逻辑结构更加清晰
    2. 模块中的变量，函数和类等可提供给其它模块或程序使用

  模块的分类:
    1. 内置模块(builtins) 在解析器的内部可以直接使用
    2. 标准库模块,安装python时已安装具可直接使用
    3. 第三方模块（通常为开源), 需要自己安装
    4. 用户自己编定的模块(可以作为其它人的第三方模块)

模块的导入 import 
import 语句
  语法:
    import 模块名1 [as 模块新名1], 模块名2[as 模块新名2], ....
  示例:
    import math  # 导入数学模块
    import sys, os  # 导入sys和os模块
    import copy as cp
  作用:
    将一个模块整体导入到当前模块中
  属性用法:
    模块名.属性名
  help(obj) 可以查看模块的文档字符串

from import 语句
  语法:
    from 模块名 import 模块属性名 [as 属性新名1], 模块属性名2 [as 属性新名2]

  作用:
    将某模块的一个或多个属性导入到当前模块的作用域
  示例:
    from math import pi
    from math import sin
    from math import factorial as fac

from import * 语句
  语法:
    from 模块名 import *
  作用:
    将某模块的所有属性导入到当前的模块
  示例:
    from math import *
    s = sin(pi/2)
    print(factorial(10))

dir 函数
  dir([对象])   返回一个字符串列表

  作用:
    1. 如果没有参数调用，则返回当前作用域内所有变量的列表
    2. 如果给定一个对象作为参数,则返回这个对象的所在变量(属性)列表
       1) 对于一个模块，返回这个模块的全部变量
       2) 对于一个类对象，返回类对象的所有变量,并递归基类对象的所有变量
       3) 对于其它对象，返回所有变量、类变量和基类变量

数学模块 math
  文档参见:
数学模块 math
模块名: math
注：
linux下为内建模块
Mac OS下为标准库模块
数学模块用法：
import math
# 或
from math import *
变量
描述
math.e
自然对数的底e
math.pi
圆周率pi
函数名
描述
math.ceil(x)
对x向上取整，比如x=1.2，返回2
math.floor(x)
对x向下取整，比如x=1.2，返回1
math.sqrt(x)
返回x的平方根
math.factorial(x)
求x的阶乘
math.log(x[, base])
返回以base为底x的对数, 如果不给出base,则以自然对数e为底
math.log10(x)
求以10为底x的对数
math.pow(x, y)
返回 x**y (x的y次方)
math.fabs(x)
返回浮点数x的绝对值
角度和弧度degrees互换

math.degree(x)
将弧度x转换为角度
math.radians(x)
将角度x转换为弧度
三角函数

math.sin(x)
返回x的正弦(x为弧度)
math.cos(x)
返回x的余弦(x为弧度)
math.tan(x)
返回x的正切(x为弧度)
math.asin(x)
返回x的反正弦(返回值为为弧度)
math.acos(x)
返回x的反余弦(返回值为为弧度)
math.atan(x)
返回x的反正切(返回值为为弧度)


时间模块 time 
  此模块提供了时间相关的函数
  文档参见:
时间模块 time
此模块提供了时间相关的函数，且一直可用
时间简介
公元纪年是从公元 0000年1月1日0时开始的
计算机元年是从1970年1月1日0时开始的,此时时间为0,之后每过一秒时间+1
UTC 时间 (Coordinated Universal Time) 是从Greenwich时间开始计算的.
UTC 时间不会因时区问题而产生错误
DST 阳光节约时间(Daylight Saving Time)，又称夏令时, 是一个经过日照时间修正后的时间
时间元组
时间元组是一个9个整型元素组成的,这九个元素自前至后依次为:
四位的年(如: 1993)
月 (1-12)
日 (1-31)
时 (0-23)
分 (0-59)
秒 (0-59)
星期几 (0-6, 周一是 0)
元旦开始日 (1-366)
夏令时修正时间 (-1, 0 or 1). 
注：
如果年份值小于100,则会自动转换为加上1900后的值
模块名: time
时间模块用法：
import time
# 或
from time import xxx
# 或
from time import *
变量
描述
time.altzone
夏令时时间与UTC时间差(秒为单位)
time.daylight
夏令时校正时间
time.timezone
本地区时间与UTC时间差(秒为单位)
time.tzname
时区名字的元组， 第一个名字为未经夏令时修正的时区名,
第一个名字为经夏令时修正后的时区名
注： CST为中国标准时间(China Standard Time UTC+8:00)
函数名
描述
time.time()
返回从计算机元年至当前时间的秒数的浮点数(UTC时间为准)
time.sleep(secs)
让程序按给定秒数的浮点数睡眠一段时间
time.gmtime([secs])
用给定秒数转换为用UTC表达的时间元组
(缺省返回当前时间元组)
time.asctime([tuple])
将时间元组转换为日期时间字符串
time.mktime(tuple)
将本地日期时间元组转换为新纪元秒数时间(UTC为准)
time.localtime([secs])
将UTC秒数时间转换为日期元组（以本地时间为准)

系统模块 sys
  此模块都是运行时系统的信息

  文档参见:
系统模块 sys
与系统相关的信息
sys模块的变量
变量
描述
sys.path
模块搜索路径 path[0] 是当前脚本程序的路径名，否则为 ''
sys.modules
已加载模块的字典
sys.version
版本信息字符串
sys.version_info
版本信息的命名元组
sys.platform
操作系统平台名称信息
sys.argv
命令行参数 argv[0] 代表当前脚本程序路径名
sys.copyright
获得Python版权相关的信息
sys.builtin_module_names
获得Python内建模块的名称（字符串元组）
标准输入输出时会用到

sys.stdin
标准输入文件对象，多用于input()
sys.stdout
标准输出文件对象,多用于print()
sys.stderr
标准错误输出文件对象, 用于输出错误信息
sys模块的方法
函数名
描述
sys.exit([arg])
退出程序，正常退出时sys.exit(0)
sys.getrecursionlimit()

sys.getrecursionlimit()
得到递归嵌套层次限制（栈的深度）
sys.setrecursionlimit(n)
得到和修改递归嵌套层次限制（栈的深度）

自定义模块
示例见:
mymod.py  # 自定义模块
''' 此示例示意自定义模块

此模块中有二个函数:
    myfac(n), mysum(n)
此模块中有两个数据:
    name1, name2
'''

def myfac(n):
    '''我是myfac 的文档字符串'''
    print("正在计算%d的阶乘!" % n)

def mysum(n):
    print("正在计算%d的和!" % n)

name1 = "audi"
name2 = "tesla"

print("mymod 模块被导入")

test_mymod.py  # 导入并测试模块
import mymod
from mymod import name1, name2

mymod.myfac(5)

mymod.mysum(100)

print(mymod.name1)
print(mymod.name2)

print('name1=', name1)
name1 = "魏老师"
print('name1=', name1)

import 语句搜索模块的路径顺序
  1. 搜索程序运行时的路径(当前路径)
  2. sys.path 提供的路径
  3. 搜索内置模块

模块的加载过程:
  在模块导入时，模块所有语句会执行
  如果一个模块已经被导入，则再次导入时不会重新执行模块内的语句

模块的重新加载
  import mymod
  import imp
  imp.reload(mymod)  # 在运行时重新加载mymod 模块

模块被导入和执行的过程:
  1. 先搜索相关路径找模块(.py文件)
  2. 判断是否有此模块对应的.py文件，如果.pyc文件比.py文件新，则直接加载.pyc文件 
  3. 否则用模块.py 文件生成.pyc并加载执行

pyc模块的编译 compile
            编译             解释执行
  mymod.py -----> mymod.pyc -------> python3

模块的文档字符串
  模块内第一个没有赋值给任何变量的字符串为文档字符串

模块的__doc__属性:
  用于绑定模块文档字符串

__file__ 属性
  绑定模块对应的文件路径

__name__ 属性
  __name__属性用来记录模块的自身的名字

  作用:
    1. 记录模块名
    2. 判断是否为主模块
  说明:
    1. 当此模块作为主模块(也就是第一个运行的模块)运行时,__name__绑定'__main__'
    2. 当此模块不是主模块时，__name__绑定模块名(文件名去掉.py后缀)

模块的__all__列表
  模块中的 __all__ 列表是一个用来存放可导出属性的字符串列表

  作用：
    限定当用from xxx import * 语句导入时，只导入 __all__ 列表内的属性

示例见:
mymod4.py
# __all__ 列表限定其它模块在用from mymod4 import *导入时
# 只导入 'myfun1', 'myfun3', 'name1'

__all__ = ['myfun1', 'myfun3', 'name1']

def myfun1():
    print("myfun1被调用")

def myfun2():
    print("myfun2被调用")

def myfun3():
    print("myfun3被调用")

name1 = 'aaaaa'
name2 = 'bbbbbbb'

模块的隐藏属性
  模块中以'_' 开头的属性，在from xxx import * 导入时将不被导入,通常称这些属性为隐藏属性

随机模块 random
  作用:
    用于模拟或生成随机输出的模块

  文档参见:
随机模块 random
说明：
random模块是用于模拟或生成随机输出的模块.
import random as R
函数名
描述
R.random()
返回一个[0, 1) 之间的随机实数
R.uniform(a,b)
返回[a,b) 区间内的随机实数
R.randrange([start,] stop[, step])
返回range(start,stop,step)中的随机数
R.choice(seq)
从序列中返回随意元素
R.shuffle(seq[, random])
随机指定序列的顺序(乱序序列）
R.sample(seq,n)
从序列中选择n个随机且不重复的元素
R.getrandbits(nbit)
以长整型的形式返回用nbit位来表示的随机数
R.seed(a=None)
用给定的数a设置随机种子,不给参数a则用当前时间设置随机种子

包(模块包) package
  包是将模块以文件夹的组织形式进行分组管理的方法

  作用:
    将一系列模块进行分类管理，有利于访问命名冲突
    可以在需要时加载一个或部分模块，而不是全部模块

  包示例:
    mypack/
        __init__.py
        menu.py
        games/
            __init__.py
            contra.py
            supermario.py
            tanks.py
        office/
            __init__.py
            excel.py
            word.py
            powerpoint.py
  创建命令:
    mkdir mypack
    cd mypack
    touch __init__.py menu.py
    mkdir games office
    cd games
    touch __init__.py contra.py supermario.py tanks.py
    cd ../office
    touch __init__.py excel.py word.py powerpoint.py

__init__.py 文件
  __init__.py 是常规包内必须存在的文件
  __init__.py 会在包加载时被自动调用

  作用:
    编写此包的内容
    在内部填写包的文档字符串
  
包的导入语法:
  # 同模块的导入规则相同
  import 包名 [as 包别名]
  import 包名.模块名 [as 模块新名]
  import 包名.子包名.模块名 [as 模块新名]

  from 包名 import 模块名 [as 模块新名]
  from 包名.子包名 import 模块名 [as 模块新名]
  from 包名.子包名.模块名 import 属性名[as 属性新名]

  from 包名 import *
  from 包名.子包名 import *
  ...

  __init__.py 内的 __all__ 列表
  
  作用:
    用来记录此包中有哪些包或模块需要在from import *语句导入时被导入
  说明:
    __all__列表只在from xxx import *语句中起作用

包的相对导入
  是指包内模块的相互导入

  语法:
    from 相对路径包或模块 import 属性或模块
    或
    from 相对路径包或模块 import *
  说明:
    包的相对导入不能用于import xxx 语句中
  相对路径:
    . 代表当前目录
    .. 代表上一级目录
    ... 代表上二级目录
    .... 以此类推
  注: 相对导入时不能超出包的外部

包的加载路径：
  同模块的加载路径搜索
    1. 搜索当前路径
    2. 搜索sys.path给定的路径

异常(基础) exception

  什么是错误
    错误是指由于逻辑或语法等导入一个程序无法正常执行的问题
  特点:
    有些错误是无法预知的

  什么是异常
    异常是程序出错时标识的一种状态
    当异常发生时，程序不会再向下执行，而转去调用此函数的地方待处理此错误并恢复为正常状态
  作用:
    用作信号,通知上层调用者有错误需要处理

try语句
  两种语法:
    try-except 语句
    try-finally 语句

try-except语句语法
    try:
        可能触发异常的语句
    except 错误类型1 [as 变量1]:
        异常处理语句1
    except 错误类型2 [as 变量2]:
        异常处理语句2
    except (错误类型3, 错误类型4) [as 变量3]:
        异常处理语句3
    ...
    except:
        异常处理语句other
    else:
        末发生异常语句
    finally:
         最终语句
  作用:
    偿式捕获异常，将程序转为正常状态并继续执行

示例见:
try_except.py
# 此示例示意 try-except语句的用法
def div_apple(n):
    print("%d个苹果您想分给几个人?" % n)
    s = input("请输入人数: ")
    cnt = int(s)  # <--此处可能触发ValueError类型的错误
    result = n / cnt  # <-- 此处可能会触发ZeroDivisionError类型的错误
    print("每个人分了%d个苹果" % result)

try:
    div_apple(10)  # 此函数可能会触发错误，分苹果失败
    print("分完苹果")
except ValueError:
    print("分苹果失败，程序已捕获通知并转为正常状态")
except ZeroDivisionError:
    print("没有人来，那苹果就拿来回吧!")

print("程序正常退出")

try-finally 语句
  语法:
    try:
        可能触发异常的语句
    finally:
        一定要执行的最终语句
  说明:
    1. finally 子句不可以省略
    2. 一定不存在except子句
  作用:
    通常用try-finally语句来做触发异常时必须要处理的事情,无论异常是否发生，finally子句都会被执行
  注:
    try-finally 语句不会改变程序的状态（正常/异常)状态

示例见:
try_finally.py
def fry_egg():
    try:
        print('打开天燃气....')
        try:
            count = int(input("请输入鸡蛋个数: "))
            print("共煎了", count, '个鸡蛋')
        finally:
            print('关闭天燃气')
    except ValueError:
        pass

fry_egg()

print("程序正常执行")

raise 语句
  作用:
    触发一个错误，让程序进入异常状态
  语法:
    raise 异常类型
    或
    raise 异常对象
示例见:
raise.py
# 此示例示意用raise语句来触发异常
def make_exception():
    print("begin")

    # 触发ValueError类型的异常并进入异常状态
    # raise ValueError
    err = ValueError("这是我自己定义的一个错误")
    raise err

    print("end")

make_exception()
# try:
#     make_exception()
#     print("make_exception调用结束")
# except ValueError as e:
#     print("try里出现了值错误通知，已捕获!!!")
#     print("接收的异常通知是: ", e)

assert 语句(断言语句)
  语法:
    assert 真值表达式, 错误数据(通常是字符串)

  作用:
    当真值表达式为False时，用错误数据创建一个 AssertionError 类型的错误，并进入异常状态
  等同于:
    if 真值表达式 == False:
        raise AssertionError(错误数据)
示例见:
get_score.py
# 此示例示意assert语句的用法 
def get_score():
    s = int(input("请输入学生成绩: "))
    # 用assert语句来断言s是否在 0~100之间
    assert 0 <= s <= 100, "用户输入的整数不在0~100之间"
    return s

try:
    score = get_score()
    print("学生成绩为:", score)
except ValueError:
    print("用户输入的成绩无法转化为整数")
except AssertionError as err:
    print("发生了断言错误，原因是:", err)

异常小结:
  语句:
    try-except
        捕获异常，偿试接收异常通知
    try-finally
        执行一定要执行的语句
    raise
        发送异常通知，将程序转为异常状态（进入异常流程)
    assert
        根据条件来触发AssertionError类型的异常
    with 语句(以后再学)

为什么要用异常处理机制
  在程序调用层数较深时，向主调函数传递错误信息需要层层return返回比较麻烦，所以用异常处理机制来解决此类问题

示例见:
exception_sample.py
def f1():
    print("开始建房子打地基")
    # err = ValueError("打地基挖出古董")
    # return err
    print("完成打地基工作")
    return "地基完成"
def f2():
    print("开始建设地上部分")
    err = ValueError("规划要建高压线")
    return err
    print("地上部分建完..")
    return "地上完成"
def f3():
    # 建地基
    r1 = f1()
    if type(r1) is not str:
        return r1
    # 建地上部分
    r2 = f2()
    if type(r2) is not str:
        return r2
    return r1 + r2
def built_house():
    '''接项目的人'''
    return f3()

h = built_house()  # 建房子的函数,此函数应当返回一个房子对象

print(h)

迭代器 Iterator
  迭代器是访问可迭代对象的工具(对象)

什么是迭代器
  迭代器是指用iter(obj) 函数返回的对象(实例)
  迭代器可以用next(it) 函数获取可迭代对象的数据

迭代器相关函数
  iter(iterable)  从可迭代对象中返回一个迭代器, iterable 必须是一个能提供一个迭代器的对象
  next(iterator)  从迭代器iterator中获取下一个记录，如果无法获取下一条记录，则触发StopIteration异常通知
说明:
  迭代器只能往前取值，不能后退

示例:
   L = [2, 3, 5, 7]
   it = iter(L)  # 让可迭代对象L 提供一个迭代器
   next(it)  # 2
   next(it)  # 3
   next(it)  # 5
   next(it)  # 7
   next(it)  # StopIteration 异常通知

   it = iter(range(1, 10, 3))
   next(it)  # 1
   next(it)  # 4
   next(it)  # 7
   next(it)  # StopIteration

示例:
    用while 语句遍历列表L中的全部元素
       L = [2, 3, 5, 7]
见iterator.py
# 此示例示意用while 语句和迭代器来访问列表
L = [2, 3, 5, 7]
it = iter(L)  # 先拿到用于访问L的迭代器
while True:
    try:
        x = next(it)
        print(x)
    except StopIteration:
        break

print('----------------')
for x in L:
    print(x)

生成器 Generator (python 2.5 及之后)
  什么是生成器
    生成器是能够动态提供数据的对象，生成器对象也是可迭代对象
  
生成器有两种:
  1. 生成器函数
  2. 生成器表达式

生成器函数定义:
  含有yield语句的函数是生成器函数，此函数被调用将返回一个生成器对象
  注:  yield 翻译为（产生或生成）

yield 语句
  语法:
    yield 表达式
  说明:
    yield 用于def 函数中，目的是将此函数作为生成器函数使用
    yield 用来生成数据，供迭代器的next(it) 函数使用
  
示例见:
yield.py
# 此示例示意函数yield 语句的生成器函数定义方式和用法
def myyield():
    '''此函数因为含有yield语句，所以是生成器函数'''
    print("即将生成1")
    yield 1
    print("即将生成3")
    yield 3
    print("即将生成5")
    yield 5
    print("即将生成7")
    yield 7
    print("生成结束")

gen = myyield()  # gen 绑定是的生成器,生成器是可迭代对 象
it = iter(gen)

# next(it)开始执行生成器函数的语句，直到遇见yield语句为止
x = next(it)
print(x)

# for x in gen:
#     print(x)  # 1 3 5 7

生成器函数说明:
  1. 生成器函数的调用将返回一个生成器对象,生成器对象是可迭代对象
  2. 生成器函数调用 return 会触发一个StopIteration异常

# 用生成函数生成一系列从0开始的整数, 示例见:
myinteger.py
# 此示例示意用生成函数生成一系列从0开始的整数
def myinteger(n):
    i = 0
    while i < n:
        yield i
        i += 1

for x in myinteger(100000000000000000000000):
    print(x)

练习:
  写一个生成器函数myeven(start, stop)，用来生成从start开始，到stop结束区间内的一系列偶数

  def myeven(start, stop):  # 不包含stop
      .... 此处自己实现

  it = iter(myeven(5, 10))
  print(next(it))  # 6
  print(next(it))  # 8

  evens = list(myeven(10, 20))
  print(evens)  # [10, 12, 14, 16, 18]
  for x in myeven(21, 30):
      print(x)  # 22 24 26 28

生成器表达式:
  语法:
    (表达式 for 变量 in 可迭代对象 if 真值表达式)
  说明:
    if 子句可以省略
  作用:
    用推导式的形式生成一个新的生成器
  示例:
    gen = (x ** 2 for x in range(1, 5))
    it = iter(gen)
    next(it)  # 1
    next(it)  # 4
    next(it)  # 9
    next(it)  # 16

看程序执行结果有什么不同:
  1) 程序1
  L = [2, 3, 5, 7]
  lst = [x + 1 for x in L]
  it = iter(lst)
  print(next(it))  # 3
  L[1] = 30
  print(next(it))  # 4

  2) 程序2
  L = [2, 3, 5, 7]
  lst = (x + 1 for x in L)
  it = iter(lst)
  print(next(it))  # 3
  L[1] = 30
  print(next(it))  # 31

迭代工具函数:
  作用：
    生成一个个性化的可迭代对象

函数名                            函数说明
  zip(iter1, iter2, iter3, ....) 返回一个zip对象，此对象用于生成一个元组，此元组的中的元素分别由iter1,iter2可迭代对象中的元素构成（元组个数由最小的可迭代对象决定)

  enumerate(iterable, start=0) 生成带索引的枚举对象，返回的迭代类型为索引-值对 (index-value) 对, 默认索引从零开始，也可用start指定

示例:
  numbers = [10086, 10000, 10010, 95588]
  names = ['中国移动', '中国电信', '中国联通']
  for t in zip(numbers, names):
      print(t)

  for n, a in zip(numbers, names):  # 等同于序列赋值
      print(a, '的客服号码是:', n)

  for t in zip(range(2), numbers, names):
      print(t)

  d = dict(zip(numbers, names))  # ???

  for t in enumerate(names):
      print(t)  # (0, '中国移动') ....

  for t in enumerate(names, 20000):
      print(t)  # (20000, '中国移动') ....

问题:
  序列:
    list, str, tuple, bytes, bytearray

字节串 bytes (也叫字节序列)
  作用:
    存储以字节为单位的数据
  说明:
    字节串是不可变的字节序列
    字节是0~255的整数

创建空字节串的字面值
    b = b''     b 绑定空字节串
    b = b""     b 绑定空字节串
    b = b'''''' b 绑定空字节串
    b = b"""""" b 绑定空字节串
创建非空字节串的字面值
    b = b'ABCD'
    b = b'\x41\x42'
字节串的构造函数bytes
    bytes()    生成一个字的字节串，等同于b''
    bytes(整型可迭代对象)  用可迭代对象初始化一个字节串
    bytes(整数n)   生成n个值为0的字节串
    bytes(字符串, encoding='utf-8')  用字符串的转换编码生成一个字节串
例:
    b = bytes()
    b = bytes(range(0, 255))
    b = bytes(10)
    b = bytes('你好', 'utf-8')

字符串的运算：
  +  +=  *  *=
  <  <=  >  >=  ==  !=
  in / not in 
  索引和切片
函数:
  len(x)
  max(x)
  min(x)
  sum(x)
  any(x)
  all(x)

bytes 与 str 的区别:
  bytes 存储字节(0~255)
  str 存储 unicode 字符(0~65535或更大)

str 与 bytes转换
        编码(encode)
    str ----------> bytes
       b = s.encode(encoding='utf-8')

        解码(decode)
    bytes -------------> str
       s = b.decode(encoding='utf-8')

字节数组 bytearray
  可变的字节序列

创建函数bytearray
   bytearray()           创建字节数组
   bytearray(可迭代对象)   同bytes(可迭代对象)
   bytearray(整数n)     ...
   bytearray(字符串, encoding='utf-8')

运算操作:
  +  +=  *  *=
  比较运算: < <= > >= == !=
  in / not in
  索引 index / 切片 slice
  (字节数组支持索引和切片赋值，规则同列表的索引和切片赋值规则)

字节数组的方法：
  详见:
    help(bytearray)

文件 file
  文件是用于数据存储的单位
  文件通常用来长期存储数据
  文件中的数据是以字节为单位进行顺序存储的

文件的操作流程
  1. 打开文件
  2. 读/写文件
  3. 关闭文件
    注: 任何的操作系统，同一个应用程序同时打开文件的数量有最大数限制，所以在用完文件后需要关闭

文件的打开函数open
  open(file, mode='rt')  用于打开一个文件，返回此文件流对象，如果打开文件失败，则会触发OSError错误

文件的关闭方法:
  F.close()    关闭文件,释放系统资源

示例见:
file_open.py
# 此示例示意文件的打开，读取及关闭
# 第一步打开文件
try:
    f = open('myfile.txt', 'rt')
    # f = open('/aaaaaaaaaa.txt', 'rt')
    print("打开文件成功!")

    # 第二步读取文件
    s = f.read()  # 读取全部内容形成字符串用s绑定
    print("文件中的内容是:", s)

    # 第三步，关闭文件
    f.close()
    print("文件已关闭")
except OSError:
    print("文件打开失败")

文本文件操作模式
   模式字符:
     't'  (默认)
   1. 默认文件中存储的数据为字符数据，以行为单位分隔，在 python 内部统一用'\n'作为换行符进行分隔
   2. 对文本文件的读写需要用字符串(str)进行读取和写入数据 

各操作系统的换行符:
  Linux换行符:          '\n'
  Windows换行符:        '\r\n'
  旧的Macintosh换行符:  '\r'
  新的Mac OS换行符:     '\n'
说明:
  在文件文件模式下，各操作系统的换行符在读入python内部时转换为字符'\n'

文件的迭代读取:
   open返回的文件流对象是可迭代对象

   示例:
    f = open('myfile.txt')
    for line in f:
        print(line)

文本文件的写操作:
  写文件模式有:
     'w'
     'x'
     'a'
    详见：
文件
mode 模式字符的含义
字符
含义
'r'
以只读方式打开(默认)
'w'
以只写方式打开，删除原有文件内容(如果文件不存在，则创建该文件并以只写方式打开)
'x'
创建一个新文件, 并以写模式打开这个文件,如果文件存在则会产生"FileExistsError"错误
'a'
以只写文件打开一个文件，如果有原文件则追加到文件末尾
'b'
用二进制模式打开
't'
文本文件模式打开 (默认)
'+'
为更新内容打开一个磁盘文件 (可读可写)
缺省模式是 'rt'
'w+b' 可以实现二进制随机读写，当打开文件时，文件内容将被清零
'r+b' 以二进制读和更新模式打开文件,打开文件时不会清空文件内容
'r+' 以文本模式读和更新模式打开文件,打开文件时不会清空文件内容
python 文件常用方法:
方法
说明
F.close()
关闭文件(关闭后文件不能再读写会发生ValueError错误)
F.readline()
读取一行数据, 如果到达文件尾则返回空行
F.readlines(max_chars=-1)
返回每行字符串的列表,max_chars为最大字符(或字节)数
F.writelines(lines)
每行字符串的列表
F.flush()
把写入文件对象的缓存内容写入到磁盘
F.read(size = -1)
从一个文件流中最多读取size个字符
F.write(text)
写一个字符串到文件流中，返回写入的字符数
二进制文件操作方法

F.tell()
返回当前文件流的绝对位置
F.seek(offset, whence=0)
改变数据流的位置，返回新的绝对位置
F.readable()
判断这个文件是否可读,可读返回True,否则返回False
F.writable()
判断这个文件是否可写,可写返回True,否则返回False
F.seekable()
返回这个文件对象是否支持随机定位
F.truncate(pos = None)
剪掉 自pos位置之后的数据，返回新的文件长度(字节为单位)

示例见:
file_write_text.py
# 此示例示意写文本文件操作
f = open('mynote.txt', 'w')  # 'w' 代表以写模式打开文件
f.write('你好')
f.write('中国!')
f.write('\n')
f.write("hello china!")
f.writelines(['aaaa\n', 'bbbb\n', 'cccc\n'])
f.close()

二进制文件操作
  默认的文件中存储的都是以字节为单位的数据，通常有人为规则的格式，需要以字节为单位进行读写

F.read() 的返回类型:
   1. 对于文本模式('t')打开的文件，返回字符串(str)
   2. 对于二进制模式('b')打开的文件，返回字节串(bytes)
  
F.write(x)
   1. 对于文本模式,x必须为字符串
   2. 对于二进制模式,x必须为字节串

以十六进制方式查看文件内容的命令:
   $ xxd 文件名
示例见:
file_write_binary.py
# 此示例示意以二进制方式写文件到'data.bin'
try:
    f = open('data.bin', 'wb')
    print("打开文件成功")
    # 写入数据
    b = b'\xe4\xb8\xad'
    f.write(b)
    f.write(b'\x00\x00')

    f.close()
except OSError:
    print("打开文件失败")

file_read_binary.py
file = open('data.bin', 'rb')
b = file.read(1)  # 读取一个字节
print("第一个字节是:", b)

b = file.read() # 读取所有的字节
print('其它所有字节是: ', b)
file.close()

F.seek() 方法
  F.seek(偏移量, 相对位置)
    偏移量:
        大于0的数代表向文件尾方向移动
        小于0代表向文件头方向移动
    相对位置:
      0 代表从文件头开始偏移
      1 代表从当前位置开始偏移
      2 代表从文件尾开始偏移
  作用:
    改变当前文件的读写位置

F.tell() 方法:
  作用:
    返回当前文件读写位置

小结:
文件操作的两种模式:
   'b'  二进制模式
   't'  文本模式

文件操作：
  读 read /readline/readlines
  写 write /writelines

汉字编码:
  问题:
    十个汉字占多少个字节

只讲两种:
  国标系列:
    GB18030(二字节或四字节编码,共27533个汉字)
      GBK(二字节编码,共21003个汉字)
        GB2312(二字节编码,共个6763汉字)
    (Windows 常用)
  国际标准:
      UNICODE32(UNICODE16)  <---> UTF-8
    (Linux, Mac OS X, IOS, Android等常用)

说明:
  python3的字符串内部都是用UNICODE来存储字符的

python 编码(encode) 字符串:
   'gb2312'
   'gbk'
   'gb18030'
   'utf-8'
   'ascii'


编码注释:
  在python 源文件第一行或第二行写入如下内容是告诉解释执行器此文件的编码类型是什么
  如:
    # -*- coding: gbk -*-
    # 设置源文件编码格式为gbk
  或
    # -*- coding: utf-8 -*-
    # 设置源文件编码格式为utf-8

示例见:
hello_gbk.py
print("你好！")
# 此示例示意gbk编码的源文件加上编码注释后
# 可以在python3下运行 

面向对象编程: Object-Oriented Programing

什么是对象:
   对象是指现实中的物体或实体

什么是面向对象
   把一切看成对象(实例), 用各种对象之间的关系来描述事务

对象都有什么特征:
  对象有很多属性(名词)
    姓名,性别, 年龄, ...
  对象有很多行为(动作，动词)
    学习，吃饭，睡觉，工作, ....

示意:
  车(类)  ------>> BYD E6 (京A.88888) (实例，对象)
        \
         \----->> BWM X5 (京B.66666) (对象)


  狗(类)  ------>> 京巴 (户籍号: 000001)
        \
         \----->> 导盲犬 (户籍号: 000002)

  int(类) ------>> 100  (对象,实例)
         \
          \----->> 200 (对象,实例)

什么是类:
  拥有相同属性和行为的对象分为一组，即为一个类
  类是用来描述对象的工具，用类可以创建此类的对象(实例)

类的创建语句: 
  class 语句
  语法:
    class 类名(继承列表):
        ''' 类文档字符串'''
        实例方法定义
        类变量定义
        类方法定义(@classmethod)
        静态方法定义(@staticmethod)
  作用:
    创建一个类
    用于描述对象的行为和属性
    用于创建此类的一个或多个同类对象(实例)
  说明:
    继承列表可以省略，省略继承列表表示类继承自object
    类名必须为标识符
    类名实质上是变量，它绑定一个类
示例见:
class.py
# 此示例示意定义最简单一个类
class Dog:
    '''这个类用于描述一种小动物的行为和属性'''
    pass

dog1 = Dog()  # 创建一个新的Dog类的对象
print(id(dog1))  # 打印这个对象的id

dog2 = Dog()  # 创建另一个Dog类的对象
print(id(dog2))

# 对比
lst1 = list()  # 创建一个空列表
print(id(lst1))

lst2 = list()  # 创建另一个空列表
print(id(lst2))

lst1.append(100)
lst2.append(200)
# dog1.append(10000)  # 只要在类中添加方法就可以实现此操作
# dog2.append(20000)

构造函数:
  构造函数调用表达式：
    类名([创建传参列表])
  作用:
    创建这个类的实例对象，并返回此实例对象的引用关系

实例说明:
  1. 实例有自己的作用域和名字空间，可以为该实例添加实例变量(也叫属性)
  2. 实例可以调用类方法和实例方法
  3. 实例可以访问类变量和实例变量

实例方法(method):
  语法:
    class 类名(继承列表):
        def 实例方法(self, 形参1, 形参2, ...):
            '''方法的文档字符串'''
            语句块
  作用:
    用于描述一个对象的行为，让此类型的全部对象都拥有相同的行为
  说明:
    实例方法的实质是函数，是定义在类内的函数
    实例方法至少有一个形参，第一个形参代表调用这个方法的实例，一般命名为'self'

实例方法的调用语法:
  实例.实例方法名(调用传参)
  或
  类名.实例方法名(实例, 调用传参)

示例见:
instance_method.py
# 此示例示意定义Dog类，并让Dog创建的对象有相同的行为
# 吃，睡，玩
class Dog:
    def eat(self, food):
        print('id为', id(self), "的小狗正在吃", food)

dog1 = Dog()  # 创建一个新的Dog类的对象
print("dog1的id", id(dog1))
dog1.eat('骨头')

dog2 = Dog()
print("dog2的id", id(dog2))
dog2.eat('包子')

实例属性 attribute (也叫实例变量)
  每个实例可以用自己的变量，称为实例变量(也叫属性)

  使用语法:
    实例.属性名
  属性的赋值规则:
    1. 首次为属性赋值则创建此属性
    2. 再次为属性赋值则改变属性的绑定关系
  作用:
    记录每个对象自身的数据
示例见:
atribute.py
# 此示例示意为每个对象添加实例属性，并通过对象的方法等访问
class Dog:
    def infos(self):
        print(self.color, '的', self.kinds)

    def eat(self, food):
        '''
        当Dog类型的对象吃东西时，用food 属性记住
        此对象吃的是什么
        '''
        print(self.color, '的', self.kinds,
              '正在吃', food)
        self.food = food

    def food_info(self):
        print(self.color, '的', self.kinds,
            '上次吃的是', self.food)
dog1 = Dog()
dog1.kinds = '京巴'  # 为dog1绑定的Dog对象添加kinds属性
dog1.color = '白色'  # 创建color实例变量 
dog1.color = '黄色'  # 改变实例变量color的绑定关系

dog2 = Dog()  # 另一个对象
dog2.kinds = '导盲犬'
dog2.color = '黑色'

dog1.infos()
dog2.infos()
# print(dog1.color, '的', dog1.kinds)  # 获取属性的数据
# print(dog2.color, '的', dog2.kinds)

dog1.eat('骨头')
dog1.food_info()

# dog2.food_info()  # dog2没有food这个属性，调用出错

练习:
  定义一个描述人的信息的类: Human
  class Human:
      def set_info(self, name, age, address='不详'):
          '''此方法为'人', 添加:姓名,年龄，家庭住址属性'''
          # ... 此处自己实现
      def show_info(self):
          '''此处显示此人的信息'''
          # ... 此处自己实现
  如:
  h1 = Human()
  h1.set_info('小张', 20, '北京市朝阳区')
  h2 = Human()
  h2.set_info('小李', 18)
  h1.show_info()  # 小张 今年 20 岁 家庭住址: 北京市朝阳区
  h2.show_info()  # 小李 今年 18 岁 家庭住址: 不详

删除属性
  del 语句
  语法:
    del 对象.属性名

示例:
  class Dog:
      pass
  dog1 = Dog()
  dog1.color = '白色'  # 添加属性
  del dog1.color 删除属性

del 语句总结:
    1) 删除变量 del a
    2) 删除列表中的元素  del L[0]
    3) 删除字典中的键    del d['name']
    4) 删除对象的属性    del dog1.color

初始化方法:
  作用:
    对新创建的对象添加属性等初始化操作
  语法格式:
    class 类名(继承列表):
        def __init__(self[, 形参列表])
            语句块
    注: [] 里的内容代表可省略

  说明:
    1. 初始化方法名必须为__init__ 不可改变
    2. 初始化方法会在构造函数创建实例后自动调用，且将实例自身通过第一个参数self 传入 __init__ 方法
    3. 构造函数的实参将通过 __init__方法的参数列表 传入到 __init__ 方法中
    4. 初始化方法内如果需要return 语句返回，则只能返回None
示例见:
init_method.py
class Car:
    def __init__(self, clr, brand, model):
        self.color = clr  # 颜色
        self.brand = brand  # 品牌
        self.model = model  # 型号
        # print('Car的初始化方法被调用')

    def run(self, speed):
        print(self.color, '的', self.brand,
              self.model, '正在以', speed, 
              '公里/小时的速度行驶')

c1 = Car('红色', '奥迪', 'A6')
c1.run(200)

# c2 = Car('蓝色', 'TESLA', 'Model S')
# c2.run(180)

练习:
  写一个学生类, 用来描述学生信息
   要求:
     1) 为该类添加初始化方法，实现在创建对象时自动设置 '姓名', '年龄', '成绩' 属性
     2) 添加 set_score 方法能为对象修改成绩信息, 并限制成绩在 0~100之间
     3) 添加show_info方法打印学生对象的信息
    class Student:
        def __init__(.......):
             .....
        def set_score(self, score):
            ....
        def show_info(self):
            ....

    s1 = Student('小魏', 17, 59)
    s1.set_score(68)
    s1.show_info()  # 小魏 今年 17 岁, 成绩是: 68

析构方法
  语法:
    class 类名(继承列表):
        def __del__(self):
            语句块
  作用:
    通常用来释放此对象占用的资源
  说明:
    1. 析构方法会在对象被销毁时自动调用
    2. python语句建议不要在对象销毁时做任何事情，因为对象销毁的时间难以确定
示例:
del_method.py
# 此示例示意析构方法的用法
class Car:
    def __init__(self, name):
        self.name = name
        print("汽车", name, '对象被创建')

    def __del__(self):
        print("汽车", self.name, '对象被销毁')

c1 = Car("BYD E6")
# del c1
# L = []
# L.append(c1)
c1 = None  # 让c1变量绑定None
while True:
    pass

print("程序结束")
  
预置的实例属性

__dict__属性
  __dict__属性绑定一个存储此实例自身变量的字典

  示例:
    class Dog:
       pass

    dog1 = Dog()
    print(dog1.__dict__)  # {}
    dog1.color = "白色"
    print(dog1.__dict__)  # {'color': '白色'}

__class__ 属性
  __class__属性绑定创建此实例的类(类实例)
  作用:
    可以借助于此属性来访问创建此实例的类

  示例:
    class Dog:
        pass
    dog1 = Dog()
    print(dog1.__class__)
    dog2 = dog1.__class__()
    print(dog2.__class__)


用于类的函数:
  isinstance(obj, class_or_tuple)  返回这个对象obj 是否是某个类的对象，或者某些类中的一个类的对象，如果是则返回True,否则返回False

  type(obj)  返回对象的类

  示例:
    isinstance(3.14, float)  # True
    isinstance('hello', str)  # True
    class Dog:
        pass
    dog1 = Dog()
    isinstance(dog1, Dog)  # True

类变量
  类变量的类的属性，此属性属于类，不属于类的实例
作用:
  通常用来存储该类对象共有的数据
说明:
  类变量可以通过类直接访问
  类变量可以通过类的实例直接访问
  类变量可以通过此类的对象的 __class__属性间接访问

语法:
  class 类名(继承列表):
      类变量名 = 表达式
      ...

示例见:
class_variable.py
# 此示例示意类变量的用法，及类和对象的关系
class Human:
    total_count = 0  # 类变量，此变量用来记录所有对象的个数
    def __init__(self, n):
        self.name = n

print("Human类内的类变量Human.total_count=",
      Human.total_count)

# 类变量可以通过类直接访问
Human.total_count += 1
print("Human.total_count=", Human.total_count)

# 类变量可以通过类的实例直接访问
h1 = Human('小张')
print("h1.total_count=", h1.total_count)
h1.total_count = 100  # 此做法是为实例添加一个变量，并不是修改类变量
print('Human.total_count=', Human.total_count)  # 1

# 类变量可以通过此类的对象的 __class__属性间接访问
h1.__class__.total_count = 200
print("Human.total_count=", Human.total_count)  # 200

# h2 = Human('小李')

类的文档字符串:
  类内没有赋值给任何变量的字符串为类的文档字符串
  类的文档字符串由类的__doc__属性绑定
  示例:
    class Dog:
        '''这是类的文档字符串'''
        pass
    >>> help(Dog)
    >>> dog1 = Dog()
    >>> help(dog1)

类的 __slots__ 属性 
  作用:
    限定一个类创建的实例只能有固定的属性(实例变量)，不允许对象添加列表以外的属性
    访止用户因错写属性的名称而发生程序错误
  说明:
    含有__slots__属性的类所创建的实例没有__dict__属性,即此实例不用字典来存储对象的属性
示例见:
slots.py
# 此示例示意__slots__属性的作用和用法
class Student:
    # 此列表让Student创建的对象只能用name和 age属性，
    # 不能有其它属性
    __slots__ = ['name', 'age']
    def __init__(self, name, age):
        self.name = name
        self.age = age

s1 = Student('Tarena', 15)
print(s1.age)  # 15
# s1.Age = 16  # 报错，不允添加__slots__列表以外的属性
print(s1.age)  # 16?

类方法:
  类方法是用于描述类的行为的方法，此方法属于类，不属于该类创建的实例　

  说明:
    1. 类方法需要使用@classmethod 装饰器定义
    2. 类方法至少有一个形参，第一个形参用于绑定类，约定写为'cls'
    3. 类实例和对象实例都可以调用类方法
    4. 类方法不能访问此类创建的对象的属性
示例见:
class_method.py
# 此示例示用类方法的使用
class A:
    v = 0  # <<<---类变量
    def __init__(self):
        self.my_v = 10000
    @classmethod
    def get_v(cls):
        '''此方法为类方法，cls用于绑定调用此方法的类
        此方法用于返回类变量v的值
        '''
        return cls.v
        # return cls.my_v  # 出错
    @classmethod
    def set_v(cls, value):
        cls.v = value

print(A.get_v())  # 0  调用类方法返回值
A.set_v(100)
print(A.get_v())  # 100

a = A()
print(a.get_v())  # 100
a.set_v(200)
print(a.get_v())  # 200
print(A.get_v())  # 200

print(a.my_v)  # 10000

# 无法用类方法访问调用此对象的a的my_v实例变量
print(a.get_v())

静态方法 @staticmethod
  静态方法是定义在类内的函数，此函数的作用域是类的内部

说明:
  静态方法需要使用staticmethod装饰器定义
  静态方法与普通函数定义相同，不需要传入self实例参数和cls类参数
  静态方法只能凭借该类或类的实例调用
  静态方法不能访问类变量和实例变量(属性)

示例见:
static_method.py
# 此示例示意静态方法的使用
class A:
    @staticmethod
    def myadd(x, y):
        return x + y

print(A.myadd(100, 200))  # 300
a = A()
print(a.myadd(300, 400))  # 700

小结 ：
  实例方法, 类方法, 静态方法, 函数

继承(inheritance)  和  派生(derived)

什么是继承/派生
  继承是从已有的类中派生出新的类，新类具有原类的行为，并能扩展新的行为
  派生类就是从一个已有的类衍生出新的类，在新的类上可以添加新的属性和行为

  作用:
    1. 用继承派生机制，可以将一些共有功能加在基类中，实现代码共享.
    2. 在不改变超类的代码的基础上改变原有的功能
  名词
    基类(base class)/超类(super class)/父类(father class)
    派生类(derived class) / 子类
  
单继承:
  语法:
    class 类名(基类名):
        语句块 
  说明:
    单继承是指派生类由一个基类衍生出来
示例见:
inherit.py
# 此示例示意单继承的语句及定义方法
class Human:
    '''此类用于描述人类的共性行为'''
    def say(self, what):
        print("say:", what)
    def walk(self, distance):
        print("走了", distance, '公里')

class Student(Human):
    def study(self, subject):
        print("学习", subject)

class Teacher(Human):
    def teach(self, subject):
        print("正在教：", subject)

h1 = Human()
h1.say('今天天气真好')
h1.walk(5)
print('-----------------')
s1 = Student()
s1.walk(4)
s1.say("走的有点累")
s1.study('python')

print('---------------')
t1 = Teacher()
t1.say("今天晚饭吃什么?")
t1.walk(3)
t1.teach("继承/派生")

思考下列表代码做什么事儿?
class MyList(list):
    def insert_head(self, n):
        self.insert(0, n)

myl = MyList(range(3, 6))
myl.insert_head(2)
myl.append(6)
print(myl)  # [2, 3, 4, 5, 6]

继承说明:
  任何类都直接可间接的继承自object类
  object类是一切类的超类

类的 __base__ 属性
  __base__属性用来记录此类的基类

示例:
  class Human:
      pass
  class Student(Human):
      pass
  class Teacher(Human):
      pass
  Student.__base__ is Human  # True

内建类的继承关系见:
  >>> help(__builtins__)

覆盖 override
什么是覆盖
  覆盖是指在有继承关系的类中，子类中实现了与基类同名的方法，在子类实例调用该方法时，实际调用的是子类中的覆盖版本的方法的现象叫覆盖

示例见：
override.py
class A:
    '''A类'''
    def work(self):
        print("A.work被调用!")

class B(A):
    '''B类'''
    def work(self):
        '''work 方法覆盖了父类的work'''
        print("B.work被调用!")

b = B()
b.work()  # B.work

a = A()
a.work()  # A.work

问题:
  在override.py中 ，b能否调用到父类的work方法?

super 函数:
  super(type, obj)   返回绑定超类的实例(要求obj必须为type类型的实例)
  super()   返回绑定超类的实例，等同于 super(__class__, 实例方法的第一个参数), 必须用在方法内调用

作用：
  返回绑定超类的实例，用超类的实例来调用其父类的覆盖方法
示例见:
super.py
# 此示例示意用super构造函数来间接调用父类的覆盖版本的方法
class A:
    def work(self):
        print("A.work()")

class B(A):
    def work(self):
        print("B.work()")

    def super_work(self):
        '''此方法先调用一下子类的work,
        再调用一下父类的work'''
        self.work()  # 调用自己的work
        # super(B, self).work()  # 调用父类的work
        super().work()  # 调用父类的work

b = B()
# b.work()  # B.work(),
# super(B, b).work()  # A.work()
b.super_work()
# super().work()  # 错的!!! super() 不能在方法使用

显式调用基类的构造方法
  当子类中实现了__init__方法，基类的构造方法并不会被调用，此时需要显式调用基类的构造方法

示例见:
super_init.py
class Human:
    def __init__(self, n, a):
        self.name = n
        self.age = a
        print("Human.__init__被调用")
    def infos(self):
        print("姓名:", self.name)
        print("年龄:", self.age)

class Student(Human):
    def __init__(self, n, a, s):
        super().__init__(n, a)  # 显式调用父类的初始化方法
        self.score = s
        print("Student.__init__被调用")

    def infos(self):
        super().infos()
        print("成绩:", self.score)

# h1 = Human('小张', 18)
# h1.infos()
s1 = Student("魏老师", 35, 60)
s1.infos()

扩展list类，创建新的类型示例:
class MyList(list):
     def __init__(self, a, age=0):
         super().__init__(a)
         self.age = age
     def infos(self):
        print("列表是:", self)
        print('年龄是:', self.age)

用于类的函数:
  issubclass(cls, class_or_tuple) 判断一个类是否继承自其它的类，如果此类cls是class或tuple中的一个派生子类，则返回 True, 否则返False

示例见:
issubclass.py
class A:
    pass

class B(A):
    pass

class C(B):
    pass

print(issubclass(C, B)) # True
print(issubclass(B, C))  # False
print(issubclass(bool, (C, B, A, int)))  # True

封装 enclosure
  封装是指隐藏类的实现细节，让使用者不用关心这些细节
  封装的目的是让使用者通过尽可能少的方法(或属性)操作对象

私有属性和方法:
  python类中以双下划线('_ _')开头，不以双下划线结尾的标识符为私有成员,私有成员只能用此类的方法进行访问和修改

示例见:
enclosure.py
# 此示例示意用私有属性和私有方法来进行封装
class A:
    def __init__(self):
        self.__p1 = 100  # 创建私有属性，此属性在类外无法访问

    def __m1(self):  # 私有方法
        print("__m1 私有方法被调用")

    def infos(self):
        print("A类的infos访问的__p1属性是:", self.__p1)
        self.__m1()  # 调用自己的私有方法
    
a = A()
# print(a.__p1)  # 出错
a.infos()
# a.__m1()  # 当前主模块不能调用A类的私有方法

多态 polymorphic

什么是多态:
  字面意思：多种状态

  状态：
    静态(编译时状态)
    动态(运行时状态)

  多态是指在有继承/派生关系的类中，调用基类对象的方法，实际能调用子类的覆盖方法的现象叫多态
  说明:
    多态调用的方法与对象相关，不与类型相关
    Python全部对象都只有运行时状态（动态) 没有"C++语言"里的编译时状态（静态)

示例见:
poly.py
# 此示例示意python的多态(动态)
class Shape:
    '''图形'''
    def draw(self):
        print("Shape的draw() 被调用")

class Point(Shape):
    def draw(self):
        print("正在画一个点")

class Circle(Point):
    def draw(self):
        print("正在画一个圆")
        
def my_draw(s):
    s.draw()  # s.draw调用谁是在运行时由s的类型动态决定
              # 此处显示出运行时状态

shape1 = Circle()
shape2 = Point()
my_draw(shape1)
my_draw(shape2)

L = [Point(), Circle(), Point(), Point(), Circle()]

for s in L:
    s.draw()

面向对象的编程语言的特征
   封装
   继承/派生
   多态

多继承 multiple inheritance
  多继承是指一个子类继承自两个或两个以上的基类

  语法:
    class 类名(基类名1, 基类名2, ...)
  说明:
    1. 一个子类同时继承自多个父类，父类中的方法可以同时被继承下来
    2. 如果两个父类中有同名的方法，则在子类中又没有覆盖，此方法时，调用结果难以确定

示例见:
multiple_inherit.py
# 此示例示意多继承的语法和用法

class Car:
    def run(self, speed):
        print('车正在以', speed, '公里/小时的速度行驶')

class Plane:
    def fly(self, height):
        print('飞机以海拔', height, '米的高空飞行')

class PlaneCar(Plane, Car):
    '''PlaneCar类同时继承是Plane和 Car类'''

p1 = PlaneCar()
p1.fly(10000)
p1.run(300)

多继承的问题（缺陷)
  标识符(名字空间)冲突的问题
    要谨慎使用多继承

示例:
multi_inherit2.py
# 小张写了一个类:
class A:
    def m(self):
        print("A.m() 被调用")

# 小李写了一个类B
class B:
    def m(self):
        print("B.m() 被调用")

# 小王感觉小张和小李写的两个类自己可以用
class AB(A, B):
    def m(self):
        print("AB.m() 被调用")
        super().m()
        super(A, self).m()

ab = AB()
ab.m()  # 当AB类没有覆盖父类的方法时会出现名字冲突问题

多继承的MRO(Method Resolution Order)问题
类的__mro__属性:
  作用:
    用来记录属性(或方法)的查找顺序

示例:
  class A:
      def go(self):
          print('A')

  class B(A):
      def go(self):
          print('B')

  class C(A):
      def go(self):
          print('C')

  class D(B, C):
      def go(self):
          print('D')

  d = D()
  d.go()  # 'D'

函数重写 overwrite
  什么是函数重写
    在自定义的类内添加相应的方法，让自定义的类生成的对象(实例)像内建对象一样进行函数操作

对象转字符串函数:
  repr(x) 返回一个能代表此对象的表达式字符串,通常:
      eval(repr(obj)) = obj
  str(obj)  通过给定对象，返回一个字符串(这个字符串通常是给人阅读的)

对象转字符串函数的重写方法
  repr() 函数的重写方法
      def __repr__(self):
          ...
          return 字符串
  str() 函数的重写方法:
      def __str__(self):
          ...
          return 字符串

str(obj) 函数调用方法说明:
  1. str(obj) 函数先查找obj.__str__() 方法，调用此方法并返回结果
  2. 如果obj.__str__() 方法不存在，则调用obj.__repr__()方法并返回结果
  3. 如果obj.__repr__方法不存在，则调用object类的__repr__实例方法显示<__main__.MyNumber object at xxx> 格式的字符串


内建函数重写
  __abs__       abs(obj) 函数调用
  __len__       len(obj) 函数调用
  __reversed__  reversed(obj) 函数调用 
  __round__     round(obj)  函数调用

示例见:
myinteger.py
# 此示例示意 abs 和len方法的重写方法
class MyInteger:
    def __init__(self, v):
        self.data = v

    def __repr__(self):
        return 'MyInteger(%d)' % self.data

    def __abs__(self):
        '''此方法用于制定abs(obj) 函数取值时返回的结果'''
        if self.data < 0:
            # 用-self.data 创建一个新的对象返回回去
            t = MyInteger(-self.data)
            return t
        return MyInteger(self.data)

i1 = MyInteger(-100)

print(i1)  # 等同于print(str(i1)) 
n = abs(i1)
print(n)  # MyInteger(100)

i2 = MyInteger(200)
print(abs(i2))  # MyInteger(200)

数值转换函数重写
  __complex__   complex(obj) 函数调用 
  __int__       int(obj) 函数调用 
  __float__     float(obj) 函数调用 
  __bool__      bool(obj) 函数调用 

示例见:
mynumber2.py
# 此示例示意自定义的对象转为python内键的数字类型
class MyNumber:
    def __init__(self, v):
        self.data = v
    def __repr__(self):
        return "MyNumber(%d)" % self.data
    def __int__(self):
        return int(self.data)

n1 = MyNumber(100.5)
n = int(n1)  # 自定义类型转为整数， 出错！！！
print(n)

布尔测试函数重写
  格式:
    def __bool__(self):
        ...
  作用:
    用于bool(obj) 函数取值
    用于if语句真值表达式中
    用于while语句的值表达式中
  说明:
    1. 当自定义类内有__bool__(self) 方法时，以此方法的返回值作为bool(obj) 的返回值
    2. 当不存在__bool__ (self) 方法时，bool(x) 返回 __len__(self) 方法的返回值是否为零来测试布尔值
    3. 当再不存在__len__(self)方法时，则直接返回True
示例见:
bool.py   
# 此示例示意__bool__方法的重写方法及用法
class MyList:
    def __init__(self, iterable=()):
        self.data = [x for x in iterable]

    def __repr__(self):
        return "MyList(%s)" % self.data

    def __len__(self):
        print("__len__被调用")
        return len(self.data)
    def __bool__(self):
        '''此方法用来制定一个bool(x) 返回的规则'''
        # 如果没有任何元素返回False
        print("__bool__方法被调用")
        if len(self.data) == 0:
            return False
        for x in self.data:
            if x:
                return True
        return False

myl = MyList([1, -2, 3, -4])
# myl = MyList()
print(myl)
print(bool(myl))  # False
print(len(myl))

myl1 = MyList([0, 0.0, False, None])    
print(bool(myl1))  # False

myl2 = MyList([0, 1, 2])
print(bool(myl2))  # True

迭代器（高级)

什么是迭代器
   可以通过next函数取值的对象就是迭代器 

迭代器协议
  迭代器协议是指对象能够使用next函数获取下一个数据，在没有下一项数据时触发一个StopIteration异常来终止迭代的约定
迭代器的实现方法:
  __next__(self) 此方法用来实现迭代器协议

什么是可迭代对象:
  是指能用iter(obj) 函数返回迭代器对象
  可迭代对象内部要定义__iter__(self) 方法来返回迭代器对象

可迭代对象的语法形式:
   class MyIterable:
       def __iter__(self):
           语句块
           return 迭代器

示例见:
myrange.py
# 此示例示意用自定义的类MyRange实现可迭代对象
# 用自定义的类MyIterator 实现迭代器
class MyIterator:
    def __init__(self, start, stop, step):
        # self.start变量用来记录迭代器的起始位置和当前位置
        self.start = start
        self.stop = stop
        self.step = step
    def __next__(self):
        '''此方法用于实现迭代器协议'''
        print("MyIterator.__next__方法被调用!")
        if self.start >= self.stop:  # 迭失终止条件
            raise StopIteration
        r = self.start  # 先将要返回的数存于变量r中
        self.start += self.step  # 迭代器后移
        return r  # 送回给next(it) 调用
class MyRange:
    def __init__(self, start, stop=None, step=1):
        if stop is None:
            stop = start
            start = 0
        self.start = start  # 起始值
        self.stop = stop    # 终止值
        self.step = step    # 步长
    def __repr__(self):
        return "MyRange(%d, %d, %d)" % (self.start,
            self.stop, self.step)
    def __iter__(self):
        '''此方法用于把MyRange类型创建的对象当做可迭代对象
        '''
        print("__iter__被调用")
        # 此处必须返回迭代器
        return MyIterator(self.start, self.stop, self.step)

L = [x for x in MyRange(5, 10)]
print(L)
print('----------------------------')
R = MyRange(5, 10, 2)
it = iter(R)  # R.__iter__
print(next(it))  # it.__next__

对象属性管理函数:
  详见:
Python3 内建函数
数值对象的构造(创建)函数
函数
说明
float(obj)
用字符串或数字转换为浮点数, 如果不给出参数，则返回0.0
int(x, base=10)
int(x=0)
用数字或字符串转换为整数,如果不给出参数，则返回0
complex(r=0.0, i=0.0)
用数字创建一个复数(实部为r,虚部为i)
bool(x)
用x创建一个布尔值(True/False)
预置(内建)的数值型函数
函数
说明
abs(x)
取x的绝对值
round(number[, ndigits])
对数值进行四舍五入, ndigits是小数向右取整的位数, 负数表示向左取整
pow(x, y, z=None)
相当于x ** y 或 x**y % z
help() 查看函数帮助：
help函数
>>> help(abs)  # 查看abs函数的帮助
基本输入输出
基本输入 input
函数
说明
input('提示字符串')
返回输入的字符串(仅Python3,'提示字符串' 可以是空)
基本输出函数 print
函数
说明
print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)
将一系列的值以字符串形式输出到
标准输出设备上,默认为终端.
参数选项
选项的关键字参数为:
sep:   两个值之间的分隔符，默认为一个空格' '
end:   输出完毕后在流末尾自动追加一个字符串,默认为换行符'\n'
file:  流对象，默认为sys.stdout.
flush: 是否立即将流进行输出
字符串编码转换函数
函数
说明
ord(c)
返回一个字符的Unicode值
chr(i)
返回i这个值所对应的 字符
整数转换为字符串函数
函数
说明
hex(i)
将整数转换为十六进制字符串
oct(i)
将整数转换为八进制字符串
bin(i)
将整数转换为二进制字符串
字符串构造函数
函数
说明
str(obj='')
将对象转换为字符串
range()函数
函数
意义
range(stop)
从零开始，每次生成一个整数后加1操作，直到stop为止（不包含stop)
range(start,stop[,step])
从start开始，每次生成一个整数后移动step，直到stop为止（不包含stop，且step可以是负数)
列表的构造函数
函数
说明
list()
# 生成一个空的列表 等同于 []
list(iterable)
# 用可迭代对象创建一个列表
元组的构造(创建)函数tuple
函数
说明
tuple()
生成一个空的元组，等同于 ()
tuple(iterable)
用可迭代对象生成一个元组
序列相关函数
函数
说明
len(seq)
返回序列的长度
max(x)
返回序列的最大值的元素
min(x)
返回序列的最小值的元素
sum(x)
返回序列中所有元素的和
any(x)
真值测试，如果列表中其中一个值为真值则返回True
all(x)
真值测试，如果列表中所有值为真值则返回True
reversed(seq)
返回反向顺序的迭代器对象
sorted(iterable, key=None, reverse=False)
返回已排序的列表
dict的构造(创建)函数dict
函数
说明
dict()
# 生成一个空的字典 等同于 {}
dict(iterable)
用可迭代对象初始化一个字典
dict(**kwargs)
命名关键字传参形式生成一个字典
集合构造(创建)函数 set
函数
说明
set()
创建一个空的集合对象(不能用{}来创建空集合)
set(iterable)
用可迭代对象创建一个新的集合对象
固定集合构造(创建)函数 frozenset
函数
说明
frozenset()
创建一个空的固定集合对象
frozenset(iterable)
用可迭代对象创建一个新的固定集合对象
globals() / locals() 函数
函数
说明
globals()
返回当前全局作用域内变量的字典
locals()
返回当前局部作用域内变量的字典
eval(), exec() 函数
函数
说明
eval(source, globals=None, locals=None)
把一个字符串source当成一个表达式来执行，返回表达式执行后的结果
exec(source, globals=None, locals=None)
把一个字符串source当成程序来执行．
高阶函数 High Order Function
函数
说明
map(func, *iterables)
用函数和对可迭代对象中的每一个元素作为参数计算出新的可迭代对象,
当最短的一个可迭代对象不再提供数据时此可迭代对象生成结束
filter(function, iterable)
筛选可迭代对象iterable中的数据,返回一个可迭代器对象，此可迭代对象
将对iterable进行筛选.函数function 将对iterable中的每个元素进行求值，
返回False则将此数据丢弃，返回True，则保留此数据
sorted(iterable, key=None, reverse=False)
将原可迭代对象的数据进行排序，生成排序后的列表iterable 可迭代对象
key 函数是用来提供一个值,这个值将作为排序的依据reverse 标志用来设
置是否降序排序
dir函数
函数
说明
dir([对象])
返回一个字符串列表
dir函数函数说明
如果没有参数调用，则返回当前作用域内的所有变量的列表
如果给定一个对象作用参数，则返回这个对象的所有变量的列表
对于一个模块,返回这个模块的全部变量
对于一个类对象，返回类对象的所有变量，并递归的基类对象的所有变量
对于其它对象返回所有变量、类变量和基类变量
迭代器函数iter和next
函数
说明
iter(iterable)
从可迭代对象中返回一个迭代器,iterable必须是能提供一个迭代器的对象
next(iterator)
从迭代器iterator中获取一下个记录，如果无法获取一下条记录，则触发 StopIteration 异常
迭代工具函数
函数
说明
zip(iter1 [,iter2 [...]])
返回一个zip对象, 此对象用于生成一个元组，此元组的个数由最小的可迭代对象决定
enumerate(iterable[, start])
生成带索引的枚举对象，返回的迭代类型为索引-值对(index-value)对,默认索引从零
开始，也可以用start指定
字节串的生成函数 bytes
函数
说明
bytes()
生成一个空的字节串 等同于 b''
bytes(整型可迭代对象)
用可迭代对象初始化一个字节串
bytes(整数n)
生成n个值为0的字节串
bytes(字符串, encoding='utf-8')
用字符串的转换编码生成一个字节串
字节数组的生成函数 bytearray
函数
说明
bytearray()
创建空的字节数组
bytearray(整数)
用可迭代对象初始化一个字节数组
bytearray(整型可迭代对象)
生成n个值为0的字节数组
bytearray(字符串, encoding='utf-8')
用字符串的转换编码生成一个字节数组
文件的打开函数
字符
含义
open(file, mode='rt')
用于打开一个文件，返回此文件流对象. 
如果打开文件失败，则会触发OSError 错误! 
如果要打开的文件不存在，则会触发FileNotFoundError 错误!
mode 模式字符的含义
字符
含义
'r'
以只读方式打开(默认)
'w'
以只写方式打开，删除原有文件内容(如果文件不存在，则创建该文件并以只写方式打开)
'x'
创建一个新文件, 并以写模式打开这个文件,如果文件存在则会产生"FileExistsError"错误
'a'
以只写文件打开一个文件，如果有原文件则追加到文件末尾
'b'
用二进制模式打开
't'
文本文件模式打开 (默认)
'+'
为更新内容打开一个磁盘文件 (可读可写)
缺省模式是 'rt'
'w+b' 可以实现二进制随机读写，当打开文件时，文件内容将被清零
'r+b' 以二进制读和更新模式打开文件,打开文件时不会清空文件内容
'r+' 以文本模式读和更新模式打开文件,打开文件时不会清空文件内容
用于类型判断的函数
函数
说明
isinstance(obj, class_or_tuple)
返回这个对象obj 是否是 某个类的对象,或者某些类中
的一个类的对象,如果是返回True,否则返回False
type(obj)
返回对象的类型
super函数
函数
说明
super(type, obj)
返回绑定超类的实例(要求obj必须为type类型的实例)
super()
返回绑定超类的实例,等同于:super(class, 实例方法的第一个参数)，必须用在方法内
用于类的函数
函数
说明
issubclass(cls, class_or_tuple)
判断一个类是否继承自其它的类,如果此类cls是class 或
tuple中的一个派生子类则返回True,否则返回False
对象的属性管理函数
函数
说明
getattr(obj, name[, default])
从一个对象得到对象的属性；getattr(x, 'y') 等同于x.y; 当属性不存在时,如果给
出default参数,则返回default,如果没有给出default 则产生一个AttributeError错误
hasattr(obj, name)
用给定的name返回对象obj是否有此属性,此种做法可以避免在getattr(obj, name)时引发错误
setattr(obj, name, value)
给对象obj的名为name的属性设置相应的值value, set(x, 'y', v) 等同于 x.y = v
delattr(obj, name)
删除对象obj中的name属性, delattr(x, 'y') 等同于 del x.y

异常（高级)
  异常相关的语句:
    try-except 
    try-finally
    raise 触发异常，发生错误通知
    assert 根据条件触发AssertionError类型的错误通知
    with 语句

with 语句
  语法:
    with 表达式1 [as 变量1],表达式2 [as 变量2], ...:
       语句块 
  作用:
    使用于对资源进行访问的场合，确保使用过程中不管是否发生异常，都会执行必须的'清理'操作，并释放资源
      如: 文件使用后自动关闭，线程中锁的自动获取和释放等
  说明:
    执行表达式 用as 子句中的变量绑定生成的对象
    with 语句并不必变异常的状态
示例见:
with.py
# 此示例示意with语句的用法
src_file = input("请输入源文件: ")
try:
    src = open(src_file, 'rb')
    try:
        try:
            # 准备打开别一个文件
            dst_file = input("请输入目标文件: ")
            dst = open(dst_file, 'wb')
            try:
                # 开始读写文件
                b = src.read()
                dst.write(b)
            finally:
                # 关闭文件
                dst.close()
        except OSError:
            print('打开写文件失败')
    finally:
        src.close()
except OSError:
    print("打开文件", src_file, '失败')

环境管理器(也有叫上下文管理器)
  1. 类内有__enter__方法 和 __exit__ 实例方法的类被称为环境管理器
  2. 能够用with语句进行管理的对象必须是环境管理器
  3. __enter__将在进入with语句时被调用，并返回由 as 变量绑定的对象
  4. __exit__ 将在离开with语句时被调用, 且可以用参数来判断在离开with语句时是否有异常发生并做出相应的处理

示例见:
with4.py
# 此示例示意环境管理器类的定义的使用
class A:
    '''此类的对象可以用于with语句进行管理'''
    def __enter__(self):
        print("已经进入with语句")
        return self

    def __exit__(self, exc_type, exc_value, exc_tb):
        print("已经离开了with语句")
        if exc_type is None:
            print("在with语句内部没有发生异常，正常离开with")
        else:
            print("离开with语句时出现异常")
            print("异常类型是:", exc_type)
            print("错误的值是:", exc_value)
try:
    with A() as a:
        print("这是with语句里打印的")
        3 / 0  # 触发异常
except:
    print("有异常发生，程序已转为正常！")

print("程序退出")

运算符重载
  什么是运算符重载：
    让自定义的类生成的对象（实例)能够实例运算符进行操作
  作用:
    让自定义类的实例像内建对象一样进行运算符操作
    让程序简洁易读
    对自定义的对象将运算符赋予新的运算规则
  说明:
    运算符重载方法的参数已经有固定的含义，不建议改变原有的意义
算术运算重载
  方法名                  运算符和表达式    说明 
  __add__(self, rhs)      self +  rhs     加法
  __sub__(self, rhs)      self -  rhs     减法
  __mul__(self, rhs)      self *  rhs     乘法
  __truediv__(self, rhs)  self /  rhs     除法
  __floordiv__(self, rhs) self // rhs     地板法
  __mod__(self, rhs)      self %  rhs     求余(取模)
  __pow__(self, rhs)      self ** rhs     冪运算

  rhs (right hands side) 右手边

示例见:
mynumber.py
# 此示例示意自定义的类通过运算符重载实现运算符操作
class MyNumber:
    def __init__(self, v):
        self.data = v

    def __repr__(self):
        return "MyNumber(%d)" % self.data

    def __add__(self, other):
        '''实现加法操作，生成一个新的对象并返回给调用者'''
        print("__add__方法被调用")
        return MyNumber(self.data + other.data)
    def __sub__(self, rhs):
        return MyNumber(self.data - rhs.data)

n1 = MyNumber(100)
n2 = MyNumber(200)
n3 = n1 + n2  #  等同于n1.__add__(n2)
# n3 = n1.__add__(n2)

print(n1, "+", n2, '=', n3)  # MyNumber(300)　???
n4 = n1 - n2
print('n4 =', n4)

二元运算符的重载方法格式:
  def __xxx__(self, other):
      运算规则的语句．．．

反向算术运算符的重载
  当运算符的左侧为内建类型时,右侧为自定义类型进行算术运算时,会出现TypeError错误,因无法修改内建类型的代码来实现运算符重载,此时需要使用反向算术运算符重载来完成重载

反向算术运算重载
  方法名                  运算符和表达式    说明 
  __radd__(self, rhs)      lhs +  self     加法
  __rsub__(self, rhs)      lhs -  self     减法
  __rmul__(self, rhs)      lhs *  self     乘法
  __rtruediv__(self, rhs)  lhs /  self     除法
  __rfloordiv__(self, rhs) lhs // self     地板法
  __rmod__(self, rhs)      lhs %  self     求余(取模)
  __rpow__(self, rhs)      lhs ** self     冪运算

复合赋值算术运算符重载
  以复合赋值算术运算符 x += y 为例, 此运算符会优先调用 x.__iadd__(y) 方法,如果没有__iadd__方法时会将复合赋值运算符拆为 x = x + y, 然后调用 x = x.__add__(y) 方法, 如果再不存在__add__方法则会触发TypeError异常

  其它复合赋值算术运算符也具有相同的规则

复合赋值算术运算重载
  方法名                  运算符和表达式    说明 
  __iadd__(self, rhs)      self +=  rhs     加法
  __isub__(self, rhs)      self -=  rhs     减法
  __imul__(self, rhs)      self *=  rhs     乘法
  __itruediv__(self, rhs)  self /=  rhs     除法
  __ifloordiv__(self, rhs) self //= rhs     地板法
  __imod__(self, rhs)      self %=  rhs     求余(取模)
  __ipow__(self, rhs)      self **= rhs     冪运算

比较运算符的重载
  方法名                  运算符和表达式    说明 
  __lt__(self, rhs)      self <  rhs     小于
  __le__(self, rhs)      self <= rhs     小于等于
  __gt__(self, rhs)      self >  rhs     大于
  __ge__(self, rhs)      self >= rhs     大于等于
  __eq__(self, rhs)      self == rhs     等于
  __ne__(self, rhs)      self != rhs     不等于

注: 比较运算符通常返回布尔值True 或False

位运算符的重载
  方法名                  运算符和表达式    说明 
  __invert__(self, rhs)    ~self    取反(一元运算符)
  __and__(self, rhs)       self &  rhs     位与
  __or__(self, rhs)        self |  rhs     位或
  __xor__(self, rhs)       self ^  rhs     位异或
  __lshift__(self, rhs)    self << rhs     左移
  __rshift__(self, rhs)    self >> rhs     右移

反向位运算符的重载
  方法名                  运算符和表达式    说明 
  __rand__(self, rhs)       lhs &  self     位与
  __ror__(self, rhs)        lhs |  self     位或
  __rxor__(self, rhs)       lhs ^  self     位异或
  __rlshift__(self, rhs)    lhs << self     左移
  __rrshift__(self, rhs)    lhs >> self     右移

复合赋值位运算符的重载
  方法名                  运算符和表达式    说明 
  __iand__(self, rhs)    self &=  rhs     位与
  __ior__(self, rhs)     self |=  rhs     位或
  __ixor__(self, rhs)    self ^=  rhs     位异或
  __ilshift__(self, rhs) self <<= rhs     左移
  __irshift__(self, rhs) self >>= rhs     右移

一元运算符的重载
    方法名　　　　　　　　　　运算符和表达式　　　说明
  __neg__(self)      - self       负号
  __pos__(self)      + self       正号
  __invert__(self)   ~ self       取反

　　语法格式:
      def __xxx__(self):
          ...

示例见:
mylist5.py
# 此示例示意一元运算符的重载
class MyList:
    def __init__(self, iterable=()):
        self.data = [x for x in iterable]

    def __repr__(self):
        return 'MyList(%r)' % self.data

    def __neg__(self):
        '''规则是正变负，负变正'''
        # L = [-x for x in self.data]
        L = (-x for x in self.data)
        return MyList(L)

L1 = MyList([1, -2, 3, -4, 5])
L2 = -L1  # 等同于L1.__neg__()
print(L2)

in / not in 运算符
  __contains__(self, e)   e in self   成员运算

示例见:
mylist6.py
# 此示例示意一元运算符的重载
class MyList:
    def __init__(self, iterable=()):
        self.data = [x for x in iterable]

    def __repr__(self):
        return 'MyList(%r)' % self.data

    def __contains__(self, e):
        return e in self.data

L1 = MyList([1, -2, 3, -4, 5])
if 3 in L1:
    print("3 在 L1内")
else:
    print("3 不在 L1内")

if 4 not in L1:
    print('4 不在L1内')
else:
    print('4 在L1内')

索引和切片运算符的重载
  []

  重载方法               运算符和表达式　　说明
__getitem__(self, i)    x = self[i]  索引/切片取值
__setitem__(self,i,val) self.[i]=val 索引/切片赋值
__delitem__(self, i)    del self[i]  del语句索引/切片

作用:
  让自定义的类型的对象能够支持索引和切片操作
示例见:
mylist7.py
# 此示例示意[]运算符的重载
class MyList:
    def __init__(self, iterable=()):
        self.data = [x for x in iterable]

    def __repr__(self):
        return 'MyList(%r)' % self.data

    def __getitem__(self, i):
        print("i =", i)
        return self.data[i]
    def __setitem__(self, i, val):
        self.data[i] = val

L1 = MyList([1, -2, 3, -4, 5])
x = L1[0]  # L1.__getitem__(0)
print(x)

L1[1] = 2  # L1.__setitem__(1, 2)
print(L1)

slice 构造函数
  作用:
    用于创建一个slice切片对象, 此对象存储一个切片起始值,终止值, 步长值信息
  格式:
    slice(start=None, stop=None, step=None) 创建 一个slice 切片对象
  slice 对象属性
    s.start 切片的起始值
    s.stop 切片的终止值
    s.step 要片的步长
示例见:
mylist8.py  # 切片取值
# 此示例示意[]运算符的重载
class MyList:
    def __init__(self, iterable=()):
        self.data = [x for x in iterable]

    def __repr__(self):
        return 'MyList(%r)' % self.data

    def __getitem__(self, i):
        print("i =", i)
        if type(i) is slice:
            print("您正在执行切片取值操作")
            print("起始值是:", i.start)
            print("终止值是:", i.stop)
            print("步长是:", i.step)
        return self.data[i]

L1 = MyList([1, -2, 3, -4, 5])
x = L1[1:8:2]
print(x)  # 

特性属性 @property
  实现其它语言所拥有的 getter 和 setter功能

  作用:
    用来模拟一个属性
    通过@property装饰器可以对模拟的属性赋值和取值加以控制

示例见:
property.py
# 此示例示意特性属性的用法
class Student:
    def __init__(self, score):
        self.__score = score

    def get_score(self):
        '''实现getter'''
        return self.__score

    def set_score(self, s):
        '''实现setter'''
        print("正在调用setter")
        if 0 <= s <= 100:
            self.__score = s
        else:
            raise ValueError

    score = property(get_score, set_score)

s = Student(59)
print(s.score)  # print(s.get_score())
s.score = 97  # s.set_score(97)
print(s.score)  # ...

property2.py
# 此示例示意特性属性的用法
class Student:
    def __init__(self, score):
        self.__score = score

    @property
    def score(self):  # score = propery(score)
        '''实现getter'''
        return self.__score


    @score.setter
    def score(self, s):
        '''实现setter'''
        print("正在调用setter")
        if 0 <= s <= 100:
            self.__score = s
        else:
            raise ValueError

s = Student(59)
print(s.score)  # print(s.get_score())
s.score = 97  # s.set_score(97)
print(s.score)  # ...

